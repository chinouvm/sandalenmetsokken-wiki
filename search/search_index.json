{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! This documentation website is meant to be a collection of different guides and cheatsheets for different programming languages and tools. Guides / cheatsheets The Python cheatsheet The Git cheatsheet","title":"Home"},{"location":"#welcome","text":"This documentation website is meant to be a collection of different guides and cheatsheets for different programming languages and tools.","title":"Welcome!"},{"location":"#guides-cheatsheets","text":"The Python cheatsheet The Git cheatsheet","title":"Guides / cheatsheets"},{"location":"FastAPI/","text":"FastAPI This is a comprehensive cheatsheet of all the basics of FastAPI. Made by Teun Explanation The key features are: Fast : Very high performance, on par with NodeJS and Go Fast to code : Increase the speed to develop features by about 200% to 300%. Fewer bugs : Reduce about 40% of human (developer) induced errors. Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Robust : Get production-ready code. With automatic interactive documentation. These key features are from FastAPI . Installation Basic installation If you are new to installing things for python project click here . First of all you will need fastapi. pip install fastapi You will also need a live server FastAPI recommends uvicorn so we shall use that. pip install \"uvicorn[standard]\" Running your first API To run your API you will need a basic main.py file. Example: from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def get_root (): return { \"response\" : \"Hello World!!!\" } You can now run the command uvicorn main:app . The command uvicorn main:app refers to: main : the file main.py (the Python \"module\"). app : the object created inside of main.py with the line app = FastAPI() . --reload : make the server restart after code changes. Only use for development. Implementation","title":"FastAPI"},{"location":"FastAPI/#fastapi","text":"This is a comprehensive cheatsheet of all the basics of FastAPI. Made by Teun","title":"FastAPI"},{"location":"FastAPI/#explanation","text":"The key features are: Fast : Very high performance, on par with NodeJS and Go Fast to code : Increase the speed to develop features by about 200% to 300%. Fewer bugs : Reduce about 40% of human (developer) induced errors. Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Robust : Get production-ready code. With automatic interactive documentation. These key features are from FastAPI .","title":"Explanation"},{"location":"FastAPI/#installation","text":"","title":"Installation"},{"location":"FastAPI/#basic-installation","text":"If you are new to installing things for python project click here . First of all you will need fastapi. pip install fastapi You will also need a live server FastAPI recommends uvicorn so we shall use that. pip install \"uvicorn[standard]\"","title":"Basic installation"},{"location":"FastAPI/#running-your-first-api","text":"To run your API you will need a basic main.py file. Example: from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def get_root (): return { \"response\" : \"Hello World!!!\" } You can now run the command uvicorn main:app . The command uvicorn main:app refers to: main : the file main.py (the Python \"module\"). app : the object created inside of main.py with the line app = FastAPI() . --reload : make the server restart after code changes. Only use for development.","title":"Running your first API"},{"location":"FastAPI/#implementation","text":"","title":"Implementation"},{"location":"Git/","tags":["coding","git","cheatsheet"],"text":"Git cheatsheet A collection of the most used git commands with descriptions on how to use them. Inspired by the Atlassian cheatsheet. Git basics # Create empty Git repo in specified directory. Run with no args to initialize current directory as a Git repo. git init <directory> # Clone repo located at`<repo> onto local machine. Original repo can be located on the local filesystem or on a remote machine via HTTP or SSH. git clone <repo> # Define author name to be used for all commits in current repo. Devs commonly use --global flag to set config options for current user. git config user.name <name> # Stage all changes in <directory> for next commit. Replace <directory> with a <file> to change a specific file. git add <directory> # Commit the staged snapshot, but instead of launching a text editor, use <message> as the commit message. git commit -m \"<message>\" # List which files are staged, unstaged, and untracked. git status # Display the entire commit history using the default format. For customization see additional options. git log # Show unstaged changes between your index and working directory. git diff Rewriting git history # Replace the last commit with the staged changes and last commit combined. Use with nothing staged to edit the last commit\u2019s message. git commit --amend # Rebase the current branch onto <base>. <base> can be a commit ID, branch name, a tag, or a relative reference to HEAD. git rebase <base> # Show a log of changes to the local repository\u2019s HEAD. Add --relative-date flag to show date info or --all to show all refs. git reflog Undoing changes # Create new commit that undoes all of the changes made in <commit>, then apply it to the current branch. git revert <commit> # Remove <file> from the staging area, but leave the working directory unchanged. This unstages a file without overwriting any changes. git reset <file> # Shows which files would be removed from working directory. Use the -f flag in place of the -n flag to execute the clean. git clean -n Git branches # List all of the branches in your repo. Add a <branch> argument to create a new branch with the name <branch>. git branch # Create and check out a new branch named <branch>. Drop the -b flag to checkout an existing branch. git checkout -b <branch> # Merge <branch> into the current branch. git merge <branch> Remote repositories # Create a new connection to a remote repo. After adding a remote, you can use <name> as a shortcut for <url> in other commands. git remote add <name> <url> # Fetches a specific <branch>, from the repo. Leave off <branch> to fetch all remote refs. git fetch <remote> <branch> # Pull the specified remote\u2019s copy of current branch and immediately merge it into the local copy. git pull <remote> # Push the branch to <remote>, along with necessary commits and objects. Creates named branch in the remote repo if it doesn\u2019t exist. git push <remote> <branch> Additional Options Extra git configurations options. Git config # Define the author name to be used for all commits by the current user. git config --global user.name <name> # Define the author email to be used for all commits by the current user. git config --global user.email <email> # Create shortcut for a Git command. E.g. alias.glog \u201clog --graph --oneline\u201d will set \u201dgit glog\u201d equivalent to \u201dgit log --graph --oneline. git config --global alias.<alias-name> <git-command> # Set text editor used by commands for all users on the machine. <editor> arg should be the command that launches the desired editor (e.g., vi). git config --system core.editor <editor> # Open the global configuration file in a text editor for manual editing. git config --global --edit Git diff # Show difference between working directory and last commit. git diff head # Show difference between staged changes and last commit git diff --cached Git reset # Reset staging area to match most recent commit, but leave the working directory unchanged git reset # Reset staging area and working directory to match most recent commit and !overwrites all changes! in the working directory git reset --hard # Move the current branch tip backward to <commit>, reset the staging area to match, but leave the working directory alone git reset <commit> # Same as previous, but resets both the staging area & working directory to match. Deletes uncommitted changes, and all commits after <commit>. git reset --hard <commit> Git log # Limit number of commits by <limit>. E.g. \u201dgit log -5\u201d will limit to 5 commits. git log --<limit> # Condense each commit to a single line. git log --oneline # Display the full diff of each commit. git log -p # Include which files were altered and the relative number of lines that were added or deleted from each of them. git log --stat # Search for commits by a particular author (<pattern>). git log --auhtor = \"<pattern>\" # Search for commits with a commit message that matches <pattern>. git log --grep = \"<pattern>\" # Show commits that occur between <since> and <until>. Args can be a commit ID, branch name, HEAD, or any other kind of revision reference. git log <since>..< until > # Only display commits that have the specified file. git log -- <file> # --graph flag draws a text based graph of commits on left side of commit msgs. --decorate adds names of branches or tags of commits shown. git log --graph --decorate Git rebase # Interactively rebase current branch onto <base>. Launches editor to enter commands for how each commit will be transferred to the new base. git rebase -i <base> Git pull # Fetch the remote\u2019s copy of current branch and rebases it into the local copy. Uses git rebase instead of merge to integrate the branches. git pull --rebase <remote> Git push # Forces the git push even if it results in a non-fast-forward merge. Do not use the --force flag unless you\u2019re absolutely sure you know what you\u2019re doing. git push <remote> --force # Push all of your local branches to the specified remote. git push <remote> -all # Tags aren\u2019t automatically pushed when you push a branch or use the --all flag. The --tags flag sends all of your local tags to the remote repo. git push <remote> --tags","title":"Git"},{"location":"Git/#git-cheatsheet","text":"A collection of the most used git commands with descriptions on how to use them. Inspired by the Atlassian cheatsheet.","title":"Git cheatsheet"},{"location":"Git/#git-basics","text":"# Create empty Git repo in specified directory. Run with no args to initialize current directory as a Git repo. git init <directory> # Clone repo located at`<repo> onto local machine. Original repo can be located on the local filesystem or on a remote machine via HTTP or SSH. git clone <repo> # Define author name to be used for all commits in current repo. Devs commonly use --global flag to set config options for current user. git config user.name <name> # Stage all changes in <directory> for next commit. Replace <directory> with a <file> to change a specific file. git add <directory> # Commit the staged snapshot, but instead of launching a text editor, use <message> as the commit message. git commit -m \"<message>\" # List which files are staged, unstaged, and untracked. git status # Display the entire commit history using the default format. For customization see additional options. git log # Show unstaged changes between your index and working directory. git diff","title":"Git basics"},{"location":"Git/#rewriting-git-history","text":"# Replace the last commit with the staged changes and last commit combined. Use with nothing staged to edit the last commit\u2019s message. git commit --amend # Rebase the current branch onto <base>. <base> can be a commit ID, branch name, a tag, or a relative reference to HEAD. git rebase <base> # Show a log of changes to the local repository\u2019s HEAD. Add --relative-date flag to show date info or --all to show all refs. git reflog","title":"Rewriting git history"},{"location":"Git/#undoing-changes","text":"# Create new commit that undoes all of the changes made in <commit>, then apply it to the current branch. git revert <commit> # Remove <file> from the staging area, but leave the working directory unchanged. This unstages a file without overwriting any changes. git reset <file> # Shows which files would be removed from working directory. Use the -f flag in place of the -n flag to execute the clean. git clean -n","title":"Undoing changes"},{"location":"Git/#git-branches","text":"# List all of the branches in your repo. Add a <branch> argument to create a new branch with the name <branch>. git branch # Create and check out a new branch named <branch>. Drop the -b flag to checkout an existing branch. git checkout -b <branch> # Merge <branch> into the current branch. git merge <branch>","title":"Git branches"},{"location":"Git/#remote-repositories","text":"# Create a new connection to a remote repo. After adding a remote, you can use <name> as a shortcut for <url> in other commands. git remote add <name> <url> # Fetches a specific <branch>, from the repo. Leave off <branch> to fetch all remote refs. git fetch <remote> <branch> # Pull the specified remote\u2019s copy of current branch and immediately merge it into the local copy. git pull <remote> # Push the branch to <remote>, along with necessary commits and objects. Creates named branch in the remote repo if it doesn\u2019t exist. git push <remote> <branch>","title":"Remote repositories"},{"location":"Git/#additional-options","text":"Extra git configurations options.","title":"Additional Options"},{"location":"Git/#git-config","text":"# Define the author name to be used for all commits by the current user. git config --global user.name <name> # Define the author email to be used for all commits by the current user. git config --global user.email <email> # Create shortcut for a Git command. E.g. alias.glog \u201clog --graph --oneline\u201d will set \u201dgit glog\u201d equivalent to \u201dgit log --graph --oneline. git config --global alias.<alias-name> <git-command> # Set text editor used by commands for all users on the machine. <editor> arg should be the command that launches the desired editor (e.g., vi). git config --system core.editor <editor> # Open the global configuration file in a text editor for manual editing. git config --global --edit","title":"Git config"},{"location":"Git/#git-diff","text":"# Show difference between working directory and last commit. git diff head # Show difference between staged changes and last commit git diff --cached","title":"Git diff"},{"location":"Git/#git-reset","text":"# Reset staging area to match most recent commit, but leave the working directory unchanged git reset # Reset staging area and working directory to match most recent commit and !overwrites all changes! in the working directory git reset --hard # Move the current branch tip backward to <commit>, reset the staging area to match, but leave the working directory alone git reset <commit> # Same as previous, but resets both the staging area & working directory to match. Deletes uncommitted changes, and all commits after <commit>. git reset --hard <commit>","title":"Git reset"},{"location":"Git/#git-log","text":"# Limit number of commits by <limit>. E.g. \u201dgit log -5\u201d will limit to 5 commits. git log --<limit> # Condense each commit to a single line. git log --oneline # Display the full diff of each commit. git log -p # Include which files were altered and the relative number of lines that were added or deleted from each of them. git log --stat # Search for commits by a particular author (<pattern>). git log --auhtor = \"<pattern>\" # Search for commits with a commit message that matches <pattern>. git log --grep = \"<pattern>\" # Show commits that occur between <since> and <until>. Args can be a commit ID, branch name, HEAD, or any other kind of revision reference. git log <since>..< until > # Only display commits that have the specified file. git log -- <file> # --graph flag draws a text based graph of commits on left side of commit msgs. --decorate adds names of branches or tags of commits shown. git log --graph --decorate","title":"Git log"},{"location":"Git/#git-rebase","text":"# Interactively rebase current branch onto <base>. Launches editor to enter commands for how each commit will be transferred to the new base. git rebase -i <base>","title":"Git rebase"},{"location":"Git/#git-pull","text":"# Fetch the remote\u2019s copy of current branch and rebases it into the local copy. Uses git rebase instead of merge to integrate the branches. git pull --rebase <remote>","title":"Git pull"},{"location":"Git/#git-push","text":"# Forces the git push even if it results in a non-fast-forward merge. Do not use the --force flag unless you\u2019re absolutely sure you know what you\u2019re doing. git push <remote> --force # Push all of your local branches to the specified remote. git push <remote> -all # Tags aren\u2019t automatically pushed when you push a branch or use the --all flag. The --tags flag sends all of your local tags to the remote repo. git push <remote> --tags","title":"Git push"},{"location":"PyInstalling/","text":"Python Installing This document will cover the basics of installing things in python (pip & venv). pip Pip is the Python package manager. It\u2019s used to install and update packages. You'll need to make sure you have the latest version op pip installed. For this you can run: py -m pip --version If there is an update available you should run: py -m pip install --upgrade pip Virtual Environments Virtual Environments allows you to manage separate package installations for different projects. They essentially allow you to create a \u201cvirtual\u201d isolated Python installation and install packages into that virtual installation. When you switch projects, you can simply create a new virtual environment and not have to worry about breaking the packages installed in the other environments. It is always recommended to use a virtual environment while developing Python applications. Run this command to create a new venv named <venv> . py -m venv <venv>","title":"Python Installing"},{"location":"PyInstalling/#python-installing","text":"This document will cover the basics of installing things in python (pip & venv).","title":"Python Installing"},{"location":"PyInstalling/#pip","text":"Pip is the Python package manager. It\u2019s used to install and update packages. You'll need to make sure you have the latest version op pip installed. For this you can run: py -m pip --version If there is an update available you should run: py -m pip install --upgrade pip","title":"pip"},{"location":"PyInstalling/#virtual-environments","text":"Virtual Environments allows you to manage separate package installations for different projects. They essentially allow you to create a \u201cvirtual\u201d isolated Python installation and install packages into that virtual installation. When you switch projects, you can simply create a new virtual environment and not have to worry about breaking the packages installed in the other environments. It is always recommended to use a virtual environment while developing Python applications. Run this command to create a new venv named <venv> . py -m venv <venv>","title":"Virtual Environments"},{"location":"Python/","tags":["coding","python","cheatsheet"],"text":"Python Cheatsheet This is a comprehensive list of all the basics of Python. Inspired by pythoncheatsheet.org The Zen of Python Long time Pythoneer Tim Peters succinctly channels the BDFL's guiding principles for Python's design into 20 aphorisms, only 19 of which have been written down. The Zen of Python , by Tim Peters Beautiful is better than ugly . Explicit is better than implicit . Simple is better than complex . Complex is better than complicated . Flat is better than nested . Sparse is better than dense . Readability counts . Special cases aren 't special enough to break the rules. Although practicality beats purity . Errors should never pass silently . Unless explicitly silenced . In the face of ambiguity , refuse the temptation to guess . There should be one -- and preferably only one -- obvious way to do it . Although that way may not be obvious at first unless you 're Dutch. Now is better than never . Although never is often better than * right * now . If the implementation is hard to explain , it 's a bad idea. If the implementation is easy to explain , it may be a good idea . Namespaces are one fucking great idea -- let 's do more of those! Python Basics Math Operators Operators Operation Example ** Exponent 2 ** 3 = 8 % Modulus/Remainder 22 % 8 = 6 // Integer division 22 // 8 = 2 / Division 22 / 8 = 2.75 * Multiplication 3 * 3 = 9 - Subtraction 5 - 2 = 3 + Addition 2 + 2 = 4 Data Types Data Type Examples Integers -2, -1, 0, 1, 2, 3, 4, 5 Floating-point numbers -1.25, -1.0, --0.5, 0.0, 0.5, 1.0, 1.25 Strings 'a', 'aa', 'aaa', 'Hello!', '11 cats' Variables You can name a variable anything as long as it obeys the following rules: It can only be one word. It can use only letters, numbers, and the underscore (_) character. It can't begin with a number. Variable name starting with an underscore (_) are considered as \"unuseful\". Example: >>> spam = \"Hello\" >>> spam \"Hello\" >>> _spam = \"Hello\" _spam should not be used again in the code. Comments Inline comment: # This is a comment Multiline comment: # This is a # multiline comment Code with a comment: a = 1 # initialization Function docstring: def foo (): \"\"\" This is a function docstring You can also user: ''' Function Docstring ''' \"\"\" The print() Function Example Code: >>> print ( 'What is your name?' ) # ask for their name >>> myName = input () >>> print ( 'It is good to meet you, {} ' . format ( myName )) What is your name ? Al It is good to meet you , Al The len() Function Evaluates to the integer value of the number of characters in a string: >>> len ( 'hello' ) 5 Note: test of emptiness of strings, lists, dictionary, etc, should not use len, but prefer direct boolean evaluation. >>> a = [ 1 , 2 , 3 ] >>> if a : >>> print ( \"the list is not empty!\" ) The str(), int() and float() Functions Integer to String or Float: >>> str ( 29 ) '29' >>> print ( 'I am {} years old.' . format ( str ( 29 ))) I am 29 years old . >>> str ( - 3.14 ) '-3.14' Float to Integer: >>> int ( 7.7 ) 7 >>> int ( 7.7 ) + 1 8 Flow Control Comparison Operators Operator Meaning == Equal to != Not equal to < Less than > Greater than <= Less than or Equal to >= Greater than or Equal to These operators evaluate to True or False depending on the values you give them. Examples: >>> 42 == 42 True >>> 40 == 42 False >>> 'hello' == 'hello' True >>> 'hello' == 'Hello' False >>> 'dog' != 'cat' True >>> 42 == 42.0 True >>> 42 == '42' False Boolean evaluation Never use == or != operator to evaluate boolean operation. Use the is or is not operators, or use implicit boolean evaluation. NO (even if they are valid Python): >>> True == True True >>> True != False True YES (even if they are valid Python): >>> True is True True >>> True is not False True These statements are equivalent: >>> if a is True : >>> pass >>> if a is not False : >>> pass >>> if a : >>> pass And these as well: >>> if a is False : >>> pass >>> if a is not True : >>> pass >>> if not a : >>> pass Boolean Operators There are three Boolean operators: and, or, and not. The and Operator\u2019s Truth Table: Expression Evaluates to True and True True True and False False False and True False False and False False The or Operator\u2019s Truth Table: Expression Evaluates to True or True True True or False True False or True True False or False False The not Operator\u2019s Truth Table: Expression Evaluates to not True False not False True Mixing Boolean and Comparison Operators >>> ( 4 < 5 ) and ( 5 < 6 ) True >>> ( 4 < 5 ) and ( 9 < 6 ) False >>> ( 1 == 2 ) or ( 2 == 2 ) True You can also use multiple Boolean operators in an expression, along with the comparison operators: >>> 2 + 2 == 4 and not 2 + 2 == 5 and 2 * 2 == 2 + 2 True if Statements if name == 'Alice' : print ( 'Hi, Alice.' ) else Statements name = 'Bob' if name == 'Alice' : print ( 'Hi, Alice.' ) else : print ( 'Hello, stranger.' ) elif Statements name = 'Bob' age = 5 if name == 'Alice' : print ( 'Hi, Alice.' ) elif age < 12 : print ( 'You are not Alice, kiddo.' ) name = 'Bob' age = 30 if name == 'Alice' : print ( 'Hi, Alice.' ) elif age < 12 : print ( 'You are not Alice, kiddo.' ) else : print ( 'You are neither Alice nor a little kid.' ) while Loop Statements spam = 0 while spam < 5 : print ( 'Hello, world.' ) spam = spam + 1 break Statements If the execution reaches a break statement, it immediately exits the while loop\u2019s clause: while True : print ( 'Please type your name.' ) name = input () if name == 'your name' : break print ( 'Thank you!' ) continue Statements When the program execution reaches a continue statement, the program execution immediately jumps back to the start of the loop. while True : print ( 'Who are you?' ) name = input () if name != 'Joe' : continue print ( 'Hello, Joe. What is the password? (It is a fish.)' ) password = input () if password == 'swordfish' : break print ( 'Access granted.' ) for Loops and the range() Function >>> print ( 'My name is' ) >>> for i in range ( 5 ): >>> print ( 'Jimmy Five Times ( {} )' . format ( str ( i ))) My name is Jimmy Five Times ( 0 ) Jimmy Five Times ( 1 ) Jimmy Five Times ( 2 ) Jimmy Five Times ( 3 ) Jimmy Five Times ( 4 ) The range() function can also be called with three arguments. The first two arguments will be the start and stop values, and the third will be the step argument. The step is the amount that the variable is increased by after each iteration. >>> for i in range ( 0 , 10 , 2 ): >>> print ( i ) 0 2 4 6 8 You can even use a negative number for the step argument to make the for loop count down instead of up. >>> for i in range ( 5 , - 1 , - 1 ): >>> print ( i ) 5 4 3 2 1 0 For else statement This allows to specify a statement to execute in case of the full loop has been executed. Only useful when a break condition can occur in the loop: >>> for i in [ 1 , 2 , 3 , 4 , 5 ]: >>> if i == 3 : >>> break >>> else : >>> print ( \"only executed when no item of the list is equal to 3\" ) Importing Modules import random for i in range ( 5 ): print ( random . randint ( 1 , 10 )) import random , sys , os , math from random import * Ending a Program Early with sys.exit() import sys while True : print ( 'Type exit to exit.' ) response = input () if response == 'exit' : sys . exit () print ( 'You typed {} .' . format ( response )) Functions >>> def hello ( name ): >>> print ( 'Hello {} ' . format ( name )) >>> >>> hello ( 'Alice' ) >>> hello ( 'Bob' ) Hello Alice Hello Bob Return Values and return Statements When creating a function using the def statement, you can specify what the return value should be with a return statement. A return statement consists of the following: The return keyword. The value or expression that the function should return. import random def getAnswer ( answerNumber ): if answerNumber == 1 : return 'It is certain' elif answerNumber == 2 : return 'It is decidedly so' elif answerNumber == 3 : return 'Yes' elif answerNumber == 4 : return 'Reply hazy try again' elif answerNumber == 5 : return 'Ask again later' elif answerNumber == 6 : return 'Concentrate and ask again' elif answerNumber == 7 : return 'My reply is no' elif answerNumber == 8 : return 'Outlook not so good' elif answerNumber == 9 : return 'Very doubtful' r = random . randint ( 1 , 9 ) fortune = getAnswer ( r ) print ( fortune ) The None Value >>> spam = print ( 'Hello!' ) Hello ! >>> spam is None True Note: never compare to None with the == operator. Always use is . Keyword Arguments and print() >>> print ( 'Hello' , end = '' ) >>> print ( 'World' ) HelloWorld >>> print ( 'cats' , 'dogs' , 'mice' ) cats dogs mice >>> print ( 'cats' , 'dogs' , 'mice' , sep = ',' ) cats , dogs , mice Local and Global Scope Code in the global scope cannot use any local variables. However, a local scope can access global variables. Code in a function\u2019s local scope cannot use variables in any other local scope. You can use the same name for different variables if they are in different scopes. That is, there can be a local variable named spam and a global variable also named spam. The global Statement If you need to modify a global variable from within a function, use the global statement: >>> def spam (): >>> global eggs >>> eggs = 'spam' >>> >>> eggs = 'global' >>> spam () >>> print ( eggs ) spam There are four rules to tell whether a variable is in a local scope or global scope: If a variable is being used in the global scope (that is, outside of all functions), then it is always a global variable. If there is a global statement for that variable in a function, it is a global variable. Otherwise, if the variable is used in an assignment statement in the function, it is a local variable. But if the variable is not used in an assignment statement, it is a global variable. Exception Handling Basic exception handling >>> def spam ( divideBy ): >>> try : >>> return 42 / divideBy >>> except ZeroDivisionError as e : >>> print ( 'Error: Invalid argument: {} ' . format ( e )) >>> >>> print ( spam ( 2 )) >>> print ( spam ( 12 )) >>> print ( spam ( 0 )) >>> print ( spam ( 1 )) 21.0 3.5 Error : Invalid argument : division by zero None 42.0 Final code in exception handling Code inside the finally section is always executed, no matter if an exception has been raised or not, and even if an exception is not caught. >>> def spam ( divideBy ): >>> try : >>> return 42 / divideBy >>> except ZeroDivisionError as e : >>> print ( 'Error: Invalid argument: {} ' . format ( e )) >>> finally : >>> print ( \"-- division finished --\" ) >>> print ( spam ( 2 )) -- division finished -- 21.0 >>> print ( spam ( 12 )) -- division finished -- 3.5 >>> print ( spam ( 0 )) Error : Invalid Argument division by zero -- division finished -- None >>> print ( spam ( 1 )) -- division finished -- 42.0 Lists >>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ 'cat' , 'bat' , 'rat' , 'elephant' ] Getting Individual Values in a List with Indexes >>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ 0 ] 'cat' >>> spam [ 1 ] 'bat' >>> spam [ 2 ] 'rat' >>> spam [ 3 ] 'elephant' Negative Indexes >>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ - 1 ] 'elephant' >>> spam [ - 3 ] 'bat' >>> 'The {} is afraid of the {} .' . format ( spam [ - 1 ], spam [ - 3 ]) 'The elephant is afraid of the bat.' Getting Sublists with Slices >>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ 0 : 4 ] [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ 1 : 3 ] [ 'bat' , 'rat' ] >>> spam [ 0 : - 1 ] [ 'cat' , 'bat' , 'rat' ] >>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [: 2 ] [ 'cat' , 'bat' ] >>> spam [ 1 :] [ 'bat' , 'rat' , 'elephant' ] Slicing the complete list will perform a copy: >>> spam2 = spam [:] [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam . append ( 'dog' ) >>> spam [ 'cat' , 'bat' , 'rat' , 'elephant' , 'dog' ] >>> spam2 [ 'cat' , 'bat' , 'rat' , 'elephant' ] Getting a List\u2019s Length with len() >>> spam = [ 'cat' , 'dog' , 'moose' ] >>> len ( spam ) 3 Changing Values in a List with Indexes >>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ 1 ] = 'aardvark' >>> spam [ 'cat' , 'aardvark' , 'rat' , 'elephant' ] >>> spam [ 2 ] = spam [ 1 ] >>> spam [ 'cat' , 'aardvark' , 'aardvark' , 'elephant' ] >>> spam [ - 1 ] = 12345 >>> spam [ 'cat' , 'aardvark' , 'aardvark' , 12345 ] List Concatenation and List Replication >>> [ 1 , 2 , 3 ] + [ 'A' , 'B' , 'C' ] [ 1 , 2 , 3 , 'A' , 'B' , 'C' ] >>> [ 'X' , 'Y' , 'Z' ] * 3 [ 'X' , 'Y' , 'Z' , 'X' , 'Y' , 'Z' , 'X' , 'Y' , 'Z' ] >>> spam = [ 1 , 2 , 3 ] >>> spam = spam + [ 'A' , 'B' , 'C' ] >>> spam [ 1 , 2 , 3 , 'A' , 'B' , 'C' ] Removing Values from Lists with del Statements >>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> del spam [ 2 ] >>> spam [ 'cat' , 'bat' , 'elephant' ] >>> del spam [ 2 ] >>> spam [ 'cat' , 'bat' ] Using for Loops with Lists >>> supplies = [ 'pens' , 'staplers' , 'flame-throwers' , 'binders' ] >>> for i , supply in enumerate ( supplies ): >>> print ( 'Index {} in supplies is: {} ' . format ( str ( i ), supply )) Index 0 in supplies is : pens Index 1 in supplies is : staplers Index 2 in supplies is : flame - throwers Index 3 in supplies is : binders Looping Through Multiple Lists with zip() >>> name = [ 'Pete' , 'John' , 'Elizabeth' ] >>> age = [ 6 , 23 , 44 ] >>> for n , a in zip ( name , age ): >>> print ( ' {} is {} years old' . format ( n , a )) Pete is 6 years old John is 23 years old Elizabeth is 44 years old The in and not in Operators >>> 'howdy' in [ 'hello' , 'hi' , 'howdy' , 'heyas' ] True >>> spam = [ 'hello' , 'hi' , 'howdy' , 'heyas' ] >>> 'cat' in spam False >>> 'howdy' not in spam False >>> 'cat' not in spam True The Multiple Assignment Trick The multiple assignment trick is a shortcut that lets you assign multiple variables with the values in a list in one line of code. So instead of doing this: >>> cat = [ 'fat' , 'orange' , 'loud' ] >>> size = cat [ 0 ] >>> color = cat [ 1 ] >>> disposition = cat [ 2 ] You could type this line of code: >>> cat = [ 'fat' , 'orange' , 'loud' ] >>> size , color , disposition = cat The multiple assignment trick can also be used to swap the values in two variables: >>> a , b = 'Alice' , 'Bob' >>> a , b = b , a >>> print ( a ) 'Bob' >>> print ( b ) 'Alice' Augmented Assignment Operators Operator Equivalent spam += 1 spam = spam + 1 spam -= 1 spam = spam - 1 spam *= 1 spam = spam * 1 spam /= 1 spam = spam / 1 spam %= 1 spam = spam % 1 Examples: >>> spam = 'Hello' >>> spam += ' world!' >>> spam 'Hello world!' >>> bacon = [ 'Zophie' ] >>> bacon *= 3 >>> bacon [ 'Zophie' , 'Zophie' , 'Zophie' ] Finding a Value in a List with the index() Method >>> spam = [ 'Zophie' , 'Pooka' , 'Fat-tail' , 'Pooka' ] >>> spam . index ( 'Pooka' ) 1 Adding Values to Lists with the append() and insert() Methods append() : >>> spam = [ 'cat' , 'dog' , 'bat' ] >>> spam . append ( 'moose' ) >>> spam [ 'cat' , 'dog' , 'bat' , 'moose' ] insert() : >>> spam = [ 'cat' , 'dog' , 'bat' ] >>> spam . insert ( 1 , 'chicken' ) >>> spam [ 'cat' , 'chicken' , 'dog' , 'bat' ] Removing Values from Lists with remove() >>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam . remove ( 'bat' ) >>> spam [ 'cat' , 'rat' , 'elephant' ] If the value appears multiple times in the list, only the first instance of the value will be removed. Sorting the Values in a List with the sort() Method >>> spam = [ 2 , 5 , 3.14 , 1 , - 7 ] >>> spam . sort () >>> spam [ - 7 , 1 , 2 , 3.14 , 5 ] >>> spam = [ 'ants' , 'cats' , 'dogs' , 'badgers' , 'elephants' ] >>> spam . sort () >>> spam [ 'ants' , 'badgers' , 'cats' , 'dogs' , 'elephants' ] You can also pass True for the reverse keyword argument to have sort() sort the values in reverse order: >>> spam . sort ( reverse = True ) >>> spam [ 'elephants' , 'dogs' , 'cats' , 'badgers' , 'ants' ] If you need to sort the values in regular alphabetical order, pass str. lower for the key keyword argument in the sort() method call: >>> spam = [ 'a' , 'z' , 'A' , 'Z' ] >>> spam . sort ( key = str . lower ) >>> spam [ 'a' , 'A' , 'z' , 'Z' ] You can use the built-in function sorted to return a new list: >>> spam = [ 'ants' , 'cats' , 'dogs' , 'badgers' , 'elephants' ] >>> sorted ( spam ) [ 'ants' , 'badgers' , 'cats' , 'dogs' , 'elephants' ] Tuple Data Type >>> eggs = ( 'hello' , 42 , 0.5 ) >>> eggs [ 0 ] 'hello' >>> eggs [ 1 : 3 ] ( 42 , 0.5 ) >>> len ( eggs ) 3 The main way that tuples are different from lists is that tuples, like strings, are immutable (can't be changed). Converting Types with the list() and tuple() Functions >>> tuple ([ 'cat' , 'dog' , 5 ]) ( 'cat' , 'dog' , 5 ) >>> list (( 'cat' , 'dog' , 5 )) [ 'cat' , 'dog' , 5 ] >>> list ( 'hello' ) [ 'h' , 'e' , 'l' , 'l' , 'o' ] Dictionaries and Structuring Data From the Python 3 documentation About dictionaries Another useful data type built into Python is the dictionary (see Mapping Types \u2014 dict ). Dictionaries are sometimes found in other languages as \u201cassociative memories\u201d or \u201cassociative arrays\u201d. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys , which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can\u2019t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like append() and extend() . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: {} . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with del . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing list(d) on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use sorted(d) instead). To check whether a single key is in the dictionary, use the in keyword. Example Dictionary: myCat = { 'size' : 'fat' , 'color' : 'gray' , 'disposition' : 'loud' } The keys(), values(), and items() Methods values(): >>> spam = { 'color' : 'red' , 'age' : 42 } >>> for v in spam . values (): >>> print ( v ) red 42 keys(): >>> for k in spam . keys (): >>> print ( k ) color age items(): >>> for i in spam . items (): >>> print ( i ) ( 'color' , 'red' ) ( 'age' , 42 ) Using the keys(), values(), and items() methods, a for loop can iterate over the keys, values, or key-value pairs in a dictionary, respectively. >>> spam = { 'color' : 'red' , 'age' : 42 } >>> >>> for k , v in spam . items (): >>> print ( 'Key: {} Value: {} ' . format ( k , str ( v ))) Key : age Value : 42 Key : color Value : red Checking Whether a Key or Value Exists in a Dictionary >>> spam = { 'name' : 'Zophie' , 'age' : 7 } >>> 'name' in spam . keys () True >>> 'Zophie' in spam . values () True >>> # You can omit the call to keys() when checking for a key >>> 'color' in spam False >>> 'color' not in spam True The get() Method Get has two parameters: key and default value if the key did not exist >>> picnic_items = { 'apples' : 5 , 'cups' : 2 } >>> 'I am bringing {} cups.' . format ( str ( picnic_items . get ( 'cups' , 0 ))) 'I am bringing 2 cups.' >>> 'I am bringing {} eggs.' . format ( str ( picnic_items . get ( 'eggs' , 0 ))) 'I am bringing 0 eggs.' The setdefault() Method Let's consider this code: spam = { 'name' : 'Pooka' , 'age' : 5 } if 'color' not in spam : spam [ 'color' ] = 'black' Using setdefault we could write the same code more succinctly: >>> spam = { 'name' : 'Pooka' , 'age' : 5 } >>> spam . setdefault ( 'color' , 'black' ) 'black' >>> spam { 'color' : 'black' , 'age' : 5 , 'name' : 'Pooka' } >>> spam . setdefault ( 'color' , 'white' ) 'black' >>> spam { 'color' : 'black' , 'age' : 5 , 'name' : 'Pooka' } Pretty Printing >>> import pprint >>> >>> message = 'It was a bright cold day in April, and the clocks were striking >>> thirteen . ' >>> count = {} >>> >>> for character in message : >>> count . setdefault ( character , 0 ) >>> count [ character ] = count [ character ] + 1 >>> >>> pprint . pprint ( count ) { ' ' : 13 , ',' : 1 , '.' : 1 , 'A' : 1 , 'I' : 1 , 'a' : 4 , 'b' : 1 , 'c' : 3 , 'd' : 3 , 'e' : 5 , 'g' : 2 , 'h' : 3 , 'i' : 6 , 'k' : 2 , 'l' : 3 , 'n' : 4 , 'o' : 2 , 'p' : 1 , 'r' : 5 , 's' : 3 , 't' : 6 , 'w' : 2 , 'y' : 1 } Merge two dictionaries # in Python 3.5+: >>> x = { 'a' : 1 , 'b' : 2 } >>> y = { 'b' : 3 , 'c' : 4 } >>> z = { ** x , ** y } >>> z { 'c' : 4 , 'a' : 1 , 'b' : 3 } # in Python 2.7 >>> z = dict ( x , ** y ) >>> z { 'c' : 4 , 'a' : 1 , 'b' : 3 } Sets From the Python 3 documentation About Sets A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Initializing a set There are two ways to create sets: using curly braces {} and the built-in function set() >>> s = { 1 , 2 , 3 } >>> s = set ([ 1 , 2 , 3 ]) When creating an empty set, be sure to not use the curly braces {} or you will get an empty dictionary instead. >>> s = {} >>> type ( s ) < class ' dict '> Sets: unordered collections of unique elements A set automatically remove all the duplicate values. >>> s = { 1 , 2 , 3 , 2 , 3 , 4 } >>> s { 1 , 2 , 3 , 4 } And as an unordered data type, they can't be indexed. >>> s = { 1 , 2 , 3 } >>> s [ 0 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'set' object does not support indexing >>> Set add() and update() Using the add() method we can add a single element to the set. >>> s = { 1 , 2 , 3 } >>> s . add ( 4 ) >>> s { 1 , 2 , 3 , 4 } And with update() , multiple ones . >>> s = { 1 , 2 , 3 } >>> s . update ([ 2 , 3 , 4 , 5 , 6 ]) >>> s { 1 , 2 , 3 , 4 , 5 , 6 } # remember, sets automatically remove duplicates Set remove() and discard() Both methods will remove an element from the set, but remove() will raise a key error if the value doesn't exist. >>> s = { 1 , 2 , 3 } >>> s . remove ( 3 ) >>> s { 1 , 2 } >>> s . remove ( 3 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > KeyError : 3 discard() won't raise any errors. >>> s = { 1 , 2 , 3 } >>> s . discard ( 3 ) >>> s { 1 , 2 } >>> s . discard ( 3 ) >>> Set union() union() or | will create a new set that contains all the elements from the sets provided. >>> s1 = { 1 , 2 , 3 } >>> s2 = { 3 , 4 , 5 } >>> s1 . union ( s2 ) # or 's1 | s2' { 1 , 2 , 3 , 4 , 5 } Set intersection intersection or & will return a set containing only the elements that are common to all of them. >>> s1 = { 1 , 2 , 3 } >>> s2 = { 2 , 3 , 4 } >>> s3 = { 3 , 4 , 5 } >>> s1 . intersection ( s2 , s3 ) # or 's1 & s2 & s3' { 3 } Set difference difference or - will return only the elements that are unique to the first set (invoked set). >>> s1 = { 1 , 2 , 3 } >>> s2 = { 2 , 3 , 4 } >>> s1 . difference ( s2 ) # or 's1 - s2' { 1 } >>> s2 . difference ( s1 ) # or 's2 - s1' { 4 } Set symetric_difference symetric_difference or ^ will return all the elements that are not common between them. >>> s1 = { 1 , 2 , 3 } >>> s2 = { 2 , 3 , 4 } >>> s1 . symmetric_difference ( s2 ) # or 's1 ^ s2' { 1 , 4 } itertools Module The itertools module is a collection of tools intended to be fast and use memory efficiently when handling iterators (like lists or dictionaries ). From the official Python 3.x documentation : About itertools The module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an \u201citerator algebra\u201d making it possible to construct specialized tools succinctly and efficiently in pure Python. The itertools module comes in the standard library and must be imported. The operator module will also be used. This module is not necessary when using itertools, but needed for some of the examples below. accumulate() Makes an iterator that returns the results of a function. itertools . accumulate ( iterable [, func ]) Example: >>> data = [ 1 , 2 , 3 , 4 , 5 ] >>> result = itertools . accumulate ( data , operator . mul ) >>> for each in result : >>> print ( each ) 1 2 6 24 120 The operator.mul takes two numbers and multiplies them: operator . mul ( 1 , 2 ) 2 operator . mul ( 2 , 3 ) 6 operator . mul ( 6 , 4 ) 24 operator . mul ( 24 , 5 ) 120 Passing a function is optional: >>> data = [ 5 , 2 , 6 , 4 , 5 , 9 , 1 ] >>> result = itertools . accumulate ( data ) >>> for each in result : >>> print ( each ) 5 7 13 17 22 31 32 If no function is designated the items will be summed: 5 5 + 2 = 7 7 + 6 = 13 13 + 4 = 17 17 + 5 = 22 22 + 9 = 31 31 + 1 = 32 combinations() Takes an iterable and a integer. This will create all the unique combination that have r members. itertools . combinations ( iterable , r ) Example: >>> shapes = [ 'circle' , 'triangle' , 'square' ,] >>> result = itertools . combinations ( shapes , 2 ) >>> for each in result : >>> print ( each ) ( 'circle' , 'triangle' ) ( 'circle' , 'square' ) ( 'triangle' , 'square' ) combinations_with_replacement() Just like combinations(), but allows individual elements to be repeated more than once. itertools . combinations_with_replacement ( iterable , r ) Example: >>> shapes = [ 'circle' , 'triangle' , 'square' ] >>> result = itertools . combinations_with_replacement ( shapes , 2 ) >>> for each in result : >>> print ( each ) ( 'circle' , 'circle' ) ( 'circle' , 'triangle' ) ( 'circle' , 'square' ) ( 'triangle' , 'triangle' ) ( 'triangle' , 'square' ) ( 'square' , 'square' ) count() Makes an iterator that returns evenly spaced values starting with number start. itertools . count ( start = 0 , step = 1 ) Example: >>> for i in itertools . count ( 10 , 3 ): >>> print ( i ) >>> if i > 20 : >>> break 10 13 16 19 22 cycle() This function cycles through an iterator endlessly. itertools . cycle ( iterable ) Example: >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'violet' ] >>> for color in itertools . cycle ( colors ): >>> print ( color ) red orange yellow green blue violet red orange When reached the end of the iterable it start over again from the beginning. chain() Take a series of iterables and return them as one long iterable. itertools . chain ( * iterables ) Example: >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' ] >>> shapes = [ 'circle' , 'triangle' , 'square' , 'pentagon' ] >>> result = itertools . chain ( colors , shapes ) >>> for each in result : >>> print ( each ) red orange yellow green blue circle triangle square pentagon compress() Filters one iterable with another. itertools . compress ( data , selectors ) Example: >>> shapes = [ 'circle' , 'triangle' , 'square' , 'pentagon' ] >>> selections = [ True , False , True , False ] >>> result = itertools . compress ( shapes , selections ) >>> for each in result : >>> print ( each ) circle square dropwhile() Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. itertools . dropwhile ( predicate , iterable ) Example: >>> data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 1 ] >>> result = itertools . dropwhile ( lambda x : x < 5 , data ) >>> for each in result : >>> print ( each ) 5 6 7 8 9 10 1 filterfalse() Makes an iterator that filters elements from iterable returning only those for which the predicate is False. itertools . filterfalse ( predicate , iterable ) Example: >>> data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 1 ] >>> result = itertools . filterfalse ( lambda x : x < 5 , data ) >>> for each in result : >>> print ( each ) 5 6 7 8 9 10 groupby() Simply put, this function groups things together. itertools . groupby ( iterable , key = None ) Example: >>> robots = [{ 'name' : 'blaster' , 'faction' : 'autobot' }, { 'name' : 'galvatron' , 'faction' : 'decepticon' }, { 'name' : 'jazz' , 'faction' : 'autobot' }, { 'name' : 'metroplex' , 'faction' : 'autobot' }, { 'name' : 'megatron' , 'faction' : 'decepticon' }, { 'name' : 'starcream' , 'faction' : 'decepticon' }] >>> for key , group in itertools . groupby ( robots , key = lambda x : x [ 'faction' ]): >>> print ( key ) >>> print ( list ( group )) autobot [{ 'name' : 'blaster' , 'faction' : 'autobot' }] decepticon [{ 'name' : 'galvatron' , 'faction' : 'decepticon' }] autobot [{ 'name' : 'jazz' , 'faction' : 'autobot' }, { 'name' : 'metroplex' , 'faction' : 'autobot' }] decepticon [{ 'name' : 'megatron' , 'faction' : 'decepticon' }, { 'name' : 'starcream' , 'faction' : 'decept islice() This function is very much like slices. This allows you to cut out a piece of an iterable. itertools . islice ( iterable , start , stop [, step ]) Example: >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' ,] >>> few_colors = itertools . islice ( colors , 2 ) >>> for each in few_colors : >>> print ( each ) red orange permutations() itertools . permutations ( iterable , r = None ) Example: >>> alpha_data = [ 'a' , 'b' , 'c' ] >>> result = itertools . permutations ( alpha_data ) >>> for each in result : >>> print ( each ) ( 'a' , 'b' , 'c' ) ( 'a' , 'c' , 'b' ) ( 'b' , 'a' , 'c' ) ( 'b' , 'c' , 'a' ) ( 'c' , 'a' , 'b' ) ( 'c' , 'b' , 'a' ) product() Creates the cartesian products from a series of iterables. >>> num_data = [ 1 , 2 , 3 ] >>> alpha_data = [ 'a' , 'b' , 'c' ] >>> result = itertools . product ( num_data , alpha_data ) >>> for each in result : print ( each ) ( 1 , 'a' ) ( 1 , 'b' ) ( 1 , 'c' ) ( 2 , 'a' ) ( 2 , 'b' ) ( 2 , 'c' ) ( 3 , 'a' ) ( 3 , 'b' ) ( 3 , 'c' ) repeat() This function will repeat an object over and over again. Unless, there is a times argument. itertools . repeat ( object [, times ]) Example: >>> for i in itertools . repeat ( \"spam\" , 3 ): print ( i ) spam spam spam starmap() Makes an iterator that computes the function using arguments obtained from the iterable. itertools . starmap ( function , iterable ) Example: >>> data = [( 2 , 6 ), ( 8 , 4 ), ( 7 , 3 )] >>> result = itertools . starmap ( operator . mul , data ) >>> for each in result : >>> print ( each ) 12 32 21 takewhile() The opposite of dropwhile(). Makes an iterator and returns elements from the iterable as long as the predicate is true. itertools . takewhile ( predicate , iterable ) Example: >>> data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 1 ] >>> result = itertools . takewhile ( lambda x : x < 5 , data ) >>> for each in result : >>> print ( each ) 1 2 3 4 tee() Return n independent iterators from a single iterable. itertools . tee ( iterable , n = 2 ) Example: >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' ] >>> alpha_colors , beta_colors = itertools . tee ( colors ) >>> for each in alpha_colors : >>> print ( each ) red orange yellow green blue >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' ] >>> alpha_colors , beta_colors = itertools . tee ( colors ) >>> for each in beta_colors : >>> print ( each ) red orange yellow green blue zip_longest() Makes an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. itertools . zip_longest ( * iterables , fillvalue = None ) Example: >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' ,] >>> data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ,] >>> for each in itertools . zip_longest ( colors , data , fillvalue = None ): >>> print ( each ) ( 'red' , 1 ) ( 'orange' , 2 ) ( 'yellow' , 3 ) ( 'green' , 4 ) ( 'blue' , 5 ) ( None , 6 ) ( None , 7 ) ( None , 8 ) ( None , 9 ) ( None , 10 ) Comprehensions List comprehension >>> a = [ 1 , 3 , 5 , 7 , 9 , 11 ] >>> [ i - 1 for i in a ] [ 0 , 2 , 4 , 6 , 8 , 10 ] Set comprehension >>> b = { \"abc\" , \"def\" } >>> { s . upper () for s in b } { \"ABC\" , \"DEF\" } Dict comprehension >>> c = { 'name' : 'Pooka' , 'age' : 5 } >>> { v : k for k , v in c . items ()} { 'Pooka' : 'name' , 5 : 'age' } A List comprehension can be generated from a dictionary: >>> c = { 'name' : 'Pooka' , 'first_name' : 'Oooka' } >>> [ \" {} : {} \" . format ( k . upper (), v . upper ()) for k , v in c . items ()] [ 'NAME:POOKA' , 'FIRST_NAME:OOOKA' ] Manipulating Strings Escape Characters Escape character Prints as \\' Single quote \\\" Double quote \\t Tab \\n Newline (linebreak) \\\\ Backslash Example: >>> print ( \"Hello there! \\n How are you? \\n I \\' m doing fine.\" ) Hello there ! How are you ? I 'm doing fine. Raw Strings A raw string completely ignores all escape characters and prints any backslash that appears in the string. >>> print ( r 'That is Carol \\' s cat.' ) That is Carol \\ 's cat. Note: mostly used for regular expression definition (see re package) Multiline Strings with Triple Quotes >>> print ( '''Dear Alice, >>> >>> Eve's cat has been arrested for catnapping, cat burglary, and extortion. >>> >>> Sincerely, >>> Bob''' ) Dear Alice , Eve 's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely , Bob To keep a nicer flow in your code, you can use the dedent function from the textwrap standard package. >>> from textwrap import dedent >>> >>> def my_function (): >>> print ( ''' >>> Dear Alice, >>> >>> Eve's cat has been arrested for catnapping, cat burglary, and extortion. >>> >>> Sincerely, >>> Bob >>> ''' ) . strip () This generates the same string than before. Indexing and Slicing Strings H e l l o w o r l d ! 0 1 2 3 4 5 6 7 8 9 10 11 >>> spam = 'Hello world!' >>> spam [ 0 ] 'H' >>> spam [ 4 ] 'o' >>> spam [ - 1 ] '!' Slicing: >>> spam [ 0 : 5 ] 'Hello' >>> spam [: 5 ] 'Hello' >>> spam [ 6 :] 'world!' >>> spam [ 6 : - 1 ] 'world' >>> spam [: - 1 ] 'Hello world' >>> spam [:: - 1 ] '!dlrow olleH' >>> spam = 'Hello world!' >>> fizz = spam [ 0 : 5 ] >>> fizz 'Hello' The in and not in Operators with Strings >>> 'Hello' in 'Hello World' True >>> 'Hello' in 'Hello' True >>> 'HELLO' in 'Hello World' False >>> '' in 'spam' True >>> 'cats' not in 'cats and dogs' False The in and not in Operators with list >>> a = [ 1 , 2 , 3 , 4 ] >>> 5 in a False >>> 2 in a True The upper(), lower(), isupper(), and islower() String Methods upper() and lower() : >>> spam = 'Hello world!' >>> spam = spam . upper () >>> spam 'HELLO WORLD!' >>> spam = spam . lower () >>> spam 'hello world!' isupper() and islower(): >>> spam = 'Hello world!' >>> spam . islower () False >>> spam . isupper () False >>> 'HELLO' . isupper () True >>> 'abc12345' . islower () True >>> '12345' . islower () False >>> '12345' . isupper () False The isX String Methods isalpha() returns True if the string consists only of letters and is not blank. isalnum() returns True if the string consists only of letters and numbers and is not blank. isdecimal() returns True if the string consists only of numeric characters and is not blank. isspace() returns True if the string consists only of spaces, tabs, and new-lines and is not blank. istitle() returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters. The startswith() and endswith() String Methods >>> 'Hello world!' . startswith ( 'Hello' ) True >>> 'Hello world!' . endswith ( 'world!' ) True >>> 'abc123' . startswith ( 'abcdef' ) False >>> 'abc123' . endswith ( '12' ) False >>> 'Hello world!' . startswith ( 'Hello world!' ) True >>> 'Hello world!' . endswith ( 'Hello world!' ) True The join() and split() String Methods join(): >>> ', ' . join ([ 'cats' , 'rats' , 'bats' ]) 'cats, rats, bats' >>> ' ' . join ([ 'My' , 'name' , 'is' , 'Simon' ]) 'My name is Simon' >>> 'ABC' . join ([ 'My' , 'name' , 'is' , 'Simon' ]) 'MyABCnameABCisABCSimon' split(): >>> 'My name is Simon' . split () [ 'My' , 'name' , 'is' , 'Simon' ] >>> 'MyABCnameABCisABCSimon' . split ( 'ABC' ) [ 'My' , 'name' , 'is' , 'Simon' ] >>> 'My name is Simon' . split ( 'm' ) [ 'My na' , 'e is Si' , 'on' ] Justifying Text with rjust(), ljust(), and center() rjust() and ljust(): >>> 'Hello' . rjust ( 10 ) ' Hello' >>> 'Hello' . rjust ( 20 ) ' Hello' >>> 'Hello World' . rjust ( 20 ) ' Hello World' >>> 'Hello' . ljust ( 10 ) 'Hello ' An optional second argument to rjust() and ljust() will specify a fill character other than a space character. Enter the following into the interactive shell: >>> 'Hello' . rjust ( 20 , '*' ) '***************Hello' >>> 'Hello' . ljust ( 20 , '-' ) 'Hello---------------' center(): >>> 'Hello' . center ( 20 ) ' Hello ' >>> 'Hello' . center ( 20 , '=' ) '=======Hello========' Removing Whitespace with strip(), rstrip(), and lstrip() >>> spam = ' Hello World ' >>> spam . strip () 'Hello World' >>> spam . lstrip () 'Hello World ' >>> spam . rstrip () ' Hello World' >>> spam = 'SpamSpamBaconSpamEggsSpamSpam' >>> spam . strip ( 'ampS' ) 'BaconSpamEggs' Copying and Pasting Strings with the pyperclip Module (need pip install) >>> import pyperclip >>> pyperclip . copy ( 'Hello world!' ) >>> pyperclip . paste () 'Hello world!' String Formatting % operator >>> name = 'Pete' >>> 'Hello %s ' % name \"Hello Pete\" We can use the %x format specifier to convert an int value to a string: >>> num = 5 >>> 'I have %x apples' % num \"I have 5 apples\" Note : For new code, using [[#String Formatting str format|str-format]] or [[#Formatted String Literals or f-strings Python 3 6|f-strings]] (Python 3.6+) is strongly recommended over the % operator. String Formatting (str.format) Python 3 introduced a new way to do string formatting that was later back-ported to Python 2.7. This makes the syntax for string formatting more regular. >>> name = 'John' >>> age = 20 ' >>> \"Hello I'm {} , my age is {} \" . format ( name , age ) \"Hello I'm John, my age is 20\" >>> \"Hello I'm {0} , my age is {1} \" . format ( name , age ) \"Hello I'm John, my age is 20\" The official Python 3.x documentation recommend str.format over the % operator: The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). Using the newer formatted string literals or the str.format() interface helps avoid these errors. These alternatives also provide more powerful, flexible and extensible approaches to formatting text. Lazy string formatting You would only use %s string formatting on functions that can do lazy parameters evaluation, the most common being logging: Prefer: >>> name = \"alice\" >>> logging . debug ( \"User name: %s \" , name ) Over: >>> logging . debug ( \"User name: {} \" . format ( name )) Or: >>> logging . debug ( \"User name: \" + name ) Formatted String Literals or f-strings (Python 3.6+) >>> name = 'Elizabeth' >>> f 'Hello { name } !' 'Hello Elizabeth! It is even possible to do inline arithmetic with it: >>> a = 5 >>> b = 10 >>> f 'Five plus ten is { a + b } and not { 2 * ( a + b ) } .' 'Five plus ten is 15 and not 30.' Template Strings A simpler and less powerful mechanism, but it is recommended when handling format strings generated by users. Due to their reduced complexity template strings are a safer choice. >>> from string import Template >>> name = 'Elizabeth' >>> t = Template ( 'Hey $name!' ) >>> t . substitute ( name = name ) 'Hey Elizabeth!' Regular Expressions Import the regex module with import re . Create a Regex object with the re.compile() function. (Remember to use a raw string.) Pass the string you want to search into the Regex object\u2019s search() method. This returns a Match object. Call the Match object\u2019s group() method to return a string of the actual matched text. All the regex functions in Python are in the re module: >>> import re Matching Regex Objects >>> phone_num_regex = re . compile ( r '\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d' ) >>> mo = phone_num_regex . search ( 'My number is 415-555-4242.' ) >>> print ( 'Phone number found: {} ' . format ( mo . group ())) Phone number found : 415 - 555 - 4242 Grouping with Parentheses >>> phone_num_regex = re . compile ( r '(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)' ) >>> mo = phone_num_regex . search ( 'My number is 415-555-4242.' ) >>> mo . group ( 1 ) '415' >>> mo . group ( 2 ) '555-4242' >>> mo . group ( 0 ) '415-555-4242' >>> mo . group () '415-555-4242' To retrieve all the groups at once: use the groups() method\u2014note the plural form for the name. >>> mo . groups () ( '415' , '555-4242' ) >>> area_code , main_number = mo . groups () >>> print ( area_code ) 415 >>> print ( main_number ) 555 - 4242 Matching Multiple Groups with the Pipe The | character is called a pipe. You can use it anywhere you want to match one of many expressions. For example, the regular expression r'Batman|Tina Fey' will match either 'Batman' or 'Tina Fey'. >>> hero_regex = re . compile ( r 'Batman|Tina Fey' ) >>> mo1 = hero_regex . search ( 'Batman and Tina Fey.' ) >>> mo1 . group () 'Batman' >>> mo2 = hero_regex . search ( 'Tina Fey and Batman.' ) >>> mo2 . group () 'Tina Fey' You can also use the pipe to match one of several patterns as part of your regex: >>> bat_regex = re . compile ( r 'Bat(man|mobile|copter|bat)' ) >>> mo = bat_regex . search ( 'Batmobile lost a wheel' ) >>> mo . group () 'Batmobile' >>> mo . group ( 1 ) 'mobile' Optional Matching with the Question Mark The ? character flags the group that precedes it as an optional part of the pattern. >>> bat_regex = re . compile ( r 'Bat(wo)?man' ) >>> mo1 = bat_regex . search ( 'The Adventures of Batman' ) >>> mo1 . group () 'Batman' >>> mo2 = bat_regex . search ( 'The Adventures of Batwoman' ) >>> mo2 . group () 'Batwoman' Matching Zero or More with the Star The * (called the star or asterisk) means \u201cmatch zero or more\u201d\u2014the group that precedes the star can occur any number of times in the text. >>> bat_regex = re . compile ( r 'Bat(wo)*man' ) >>> mo1 = bat_regex . search ( 'The Adventures of Batman' ) >>> mo1 . group () 'Batman' >>> mo2 = bat_regex . search ( 'The Adventures of Batwoman' ) >>> mo2 . group () 'Batwoman' >>> mo3 = bat_regex . search ( 'The Adventures of Batwowowowoman' ) >>> mo3 . group () 'Batwowowowoman' Matching One or More with the Plus While * means \u201cmatch zero or more,\u201d the + (or plus) means \u201cmatch one or more\u201d. The group preceding a plus must appear at least once. It is not optional: >>> bat_regex = re . compile ( r 'Bat(wo)+man' ) >>> mo1 = bat_regex . search ( 'The Adventures of Batwoman' ) >>> mo1 . group () 'Batwoman' >>> mo2 = bat_regex . search ( 'The Adventures of Batwowowowoman' ) >>> mo2 . group () 'Batwowowowoman' >>> mo3 = bat_regex . search ( 'The Adventures of Batman' ) >>> mo3 is None True Matching Specific Repetitions with Curly Brackets If you have a group that you want to repeat a specific number of times, follow the group in your regex with a number in curly brackets. For example, the regex (Ha){3} will match the string 'HaHaHa', but it will not match 'HaHa', since the latter has only two repeats of the (Ha) group. Instead of one number, you can specify a range by writing a minimum, a comma, and a maximum in between the curly brackets. For example, the regex (Ha){3,5} will match 'HaHaHa', 'HaHaHaHa', and 'HaHaHaHaHa'. >>> ha_regex = re . compile ( r '(Ha) {3} ' ) >>> mo1 = ha_regex . search ( 'HaHaHa' ) >>> mo1 . group () 'HaHaHa' >>> mo2 = ha_regex . search ( 'Ha' ) >>> mo2 is None True Greedy and Nongreedy Matching Python\u2019s regular expressions are greedy by default, which means that in ambiguous situations they will match the longest string possible. The non-greedy version of the curly brackets, which matches the shortest string possible, has the closing curly bracket followed by a question mark. >>> greedy_ha_regex = re . compile ( r '(Ha){3,5}' ) >>> mo1 = greedy_ha_regex . search ( 'HaHaHaHaHa' ) >>> mo1 . group () 'HaHaHaHaHa' >>> nongreedy_ha_regex = re . compile ( r '(Ha){3,5}?' ) >>> mo2 = nongreedy_ha_regex . search ( 'HaHaHaHaHa' ) >>> mo2 . group () 'HaHaHa' The findall() Method In addition to the search() method, Regex objects also have a findall() method. While search() will return a Match object of the first matched text in the searched string, the findall() method will return the strings of every match in the searched string. >>> phone_num_regex = re . compile ( r '\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d' ) # has no groups >>> phone_num_regex . findall ( 'Cell: 415-555-9999 Work: 212-555-0000' ) [ '415-555-9999' , '212-555-0000' ] To summarize what the findall() method returns, remember the following: When called on a regex with no groups, such as \\d-\\d\\d\\d-\\d\\d\\d\\d , the method findall() returns a list of ng matches, such as ['415-555-9999', '212-555-0000']. When called on a regex that has groups, such as ( \\d\\d\\d)-(d\\d)-(\\d\\d\\d\\d ), the method findall() returns a list of es of strings (one string for each group), such as [('415', '555', '9999'), ('212', '555', '0000')]. Making Your Own Character Classes There are times when you want to match a set of characters but the shorthand character classes ( \\d, \\w, \\s, and so on) are too broad. You can define your own character class using square brackets. For example, the character class [aeiouAEIOU] will match any vowel, both lowercase and uppercase. >>> vowel_regex = re . compile ( r '[aeiouAEIOU]' ) >>> vowel_regex . findall ( 'Robocop eats baby food. BABY FOOD.' ) [ 'o' , 'o' , 'o' , 'e' , 'a' , 'a' , 'o' , 'o' , 'A' , 'O' , 'O' ] You can also include ranges of letters or numbers by using a hyphen. For example, the character class [a-zA-Z0-9] will match all lowercase letters, uppercase letters, and numbers. By placing a caret character (^) just after the character class\u2019s opening bracket, you can make a negative character class. A negative character class will match all the characters that are not in the character class. For example, enter the following into the interactive shell: >>> consonant_regex = re . compile ( r '[^aeiouAEIOU]' ) >>> consonant_regex . findall ( 'Robocop eats baby food. BABY FOOD.' ) [ 'R' , 'b' , 'c' , 'p' , ' ' , 't' , 's' , ' ' , 'b' , 'b' , 'y' , ' ' , 'f' , 'd' , '.' , ' ', ' B ', ' B ', ' Y ', ' ', ' F ', ' D ', ' . '] The Caret and Dollar Sign Characters You can also use the caret symbol (^) at the start of a regex to indicate that a match must occur at the beginning of the searched text. Likewise, you can put a dollar sign ( \\$ ) at the end of the regex to indicate the string must end with this regex pattern. And you can use the ^ and \\$ together to indicate that the entire string must match the regex\u2014that is, it\u2019s not enough for a match to be made on some subset of the string. The r'^Hello' regular expression string matches strings that begin with 'Hello': >>> begins_with_hello = re . compile ( r '^Hello' ) >>> begins_with_hello . search ( 'Hello world!' ) < _sre . SRE_Match object ; span = ( 0 , 5 ), match = 'Hello' > >>> begins_with_hello . search ( 'He said hello.' ) is None True The r'\\d\\$' regular expression string matches strings that end with a numeric character from 0 to 9: >>> whole_string_is_num = re . compile ( r '^\\d+$' ) >>> whole_string_is_num . search ( '1234567890' ) < _sre . SRE_Match object ; span = ( 0 , 10 ), match = '1234567890' > >>> whole_string_is_num . search ( '12345xyz67890' ) is None True >>> whole_string_is_num . search ( '12 34567890' ) is None True The Wildcard Character The . (or dot) character in a regular expression is called a wildcard and will match any character except for a newline: >>> at_regex = re . compile ( r '.at' ) >>> at_regex . findall ( 'The cat in the hat sat on the flat mat.' ) [ 'cat' , 'hat' , 'sat' , 'lat' , 'mat' ] Matching Everything with Dot-Star >>> name_regex = re . compile ( r 'First Name: (.*) Last Name: (.*)' ) >>> mo = name_regex . search ( 'First Name: Al Last Name: Sweigart' ) >>> mo . group ( 1 ) 'Al' >>> mo . group ( 2 ) 'Sweigart' The dot-star uses greedy mode: It will always try to match as much text as possible. To match any and all text in a nongreedy fashion, use the dot, star, and question mark (.*?). The question mark tells Python to match in a nongreedy way: >>> nongreedy_regex = re . compile ( r '<.*?>' ) >>> mo = nongreedy_regex . search ( '<To serve man> for dinner.>' ) >>> mo . group () '<To serve man>' >>> greedy_regex = re . compile ( r '<.*>' ) >>> mo = greedy_regex . search ( '<To serve man> for dinner.>' ) >>> mo . group () '<To serve man> for dinner.>' Matching Newlines with the Dot Character The dot-star will match everything except a newline. By passing re.DOTALL as the second argument to re.compile(), you can make the dot character match all characters, including the newline character: >>> no_newline_regex = re . compile ( '.*' ) >>> no_newline_regex . search ( 'Serve the public trust. \\n Protect the innocent. \\n Uphold the law.' ) . group () 'Serve the public trust.' >>> newline_regex = re . compile ( '.*' , re . DOTALL ) >>> newline_regex . search ( 'Serve the public trust. \\n Protect the innocent. \\n Uphold the law.' ) . group () 'Serve the public trust. \\n Protect the innocent. \\n Uphold the law.' Review of Regex Symbols Symbol Matches ? zero or one of the preceding group. * zero or more of the preceding group. + one or more of the preceding group. {n} exactly n of the preceding group. {n,} n or more of the preceding group. {,m} 0 to m if the preceding group. {n,m} at least n and at most m of the preceding p. {n,m}? or *? or +? performs a nongreedy match of the preceding p. ^spam means the string must begin with spam. spam$ means the string must end with spam. . any character, except newline characters. \\d , \\w , and \\s a digit, word or space character, respectively. \\D , \\W , and \\S anything except a digit, word or space, respectively. [abc] any character between the brackets (such as a, b). [^abc] any character that isn't between the brackets. Case-Insensitive Matching To make your regex case-insensitive, you can pass re.IGNORECASE or re.I as a second argument to re.compile(): >>> robocop = re . compile ( r 'robocop' , re . I ) >>> robocop . search ( 'Robocop is part man, part machine, all cop.' ) . group () 'Robocop' >>> robocop . search ( 'ROBOCOP protects the innocent.' ) . group () 'ROBOCOP' >>> robocop . search ( 'Al, why does your programming book talk about robocop so much?' ) . group () 'robocop' Substituting Strings with the sub() Method The sub() method for Regex objects is passed two arguments: The first argument is a string to replace any matches. The second is the string for the regular expression. The sub() method returns a string with the substitutions applied: >>> names_regex = re . compile ( r 'Agent \\w+' ) >>> names_regex . sub ( 'CENSORED' , 'Agent Alice gave the secret documents to Agent Bob.' ) 'CENSORED gave the secret documents to CENSORED.' Another example: >>> agent_names_regex = re . compile ( r 'Agent (\\w)\\w*' ) >>> agent_names_regex . sub ( r '\\1****' , 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.' ) A **** told C **** that E **** knew B **** was a double agent . ' Managing Complex Regexes To tell the re.compile() function to ignore whitespace and comments inside the regular expression string, \u201cverbose mode\u201d can be enabled by passing the variable re.VERBOSE as the second argument to re.compile(). Now instead of a hard-to-read regular expression like this: phone_regex = re . compile ( r '((\\d {3} |\\(\\d {3} \\))?(\\s|-|\\.)?\\d {3} (\\s|-|\\.)\\d {4} (\\s*(ext|x|ext.)\\s*\\d{2,5})?)' ) you can spread the regular expression over multiple lines with comments like this: phone_regex = re . compile ( r '''( (\\d {3} |\\(\\d {3} \\))? # area code (\\s|-|\\.)? # separator \\d {3} # first 3 digits (\\s|-|\\.) # separator \\d {4} # last 4 digits (\\s*(ext|x|ext.)\\s*\\d{2,5})? # extension )''' , re . VERBOSE ) Handling File and Directory Paths There are two main modules in Python that deals with path manipulation. One is the os.path module and the other is the pathlib module. The pathlib module was added in Python 3.4, offering an object-oriented way to handle file system paths. Backslash on Windows and Forward Slash on OS X and Linux On Windows, paths are written using backslashes ( \\ ) as the separator between folder names. On Unix based operating system such as macOS, Linux, and BSDs, the forward slash ( / ) is used as the path separator. Joining paths can be a headache if your code needs to work on different platforms. Fortunately, Python provides easy ways to handle this. We will showcase how to deal with this with both os.path.join and pathlib.Path.joinpath Using os.path.join on Windows: >>> import os >>> os . path . join ( 'usr' , 'bin' , 'spam' ) 'usr \\\\ bin \\\\ spam' And using pathlib on *nix: >>> from pathlib import Path >>> print ( Path ( 'usr' ) . joinpath ( 'bin' ) . joinpath ( 'spam' )) usr / bin / spam pathlib also provides a shortcut to joinpath using the / operator: >>> from pathlib import Path >>> print ( Path ( 'usr' ) / 'bin' / 'spam' ) usr / bin / spam Notice the path separator is different between Windows and Unix based operating system, that's why you want to use one of the above methods instead of adding strings together to join paths together. Joining paths is helpful if you need to create different file paths under the same directory. Using os.path.join on Windows: >>> my_files = [ 'accounts.txt' , 'details.csv' , 'invite.docx' ] >>> for filename in my_files : >>> print ( os . path . join ( 'C: \\\\ Users \\\\ asweigart' , filename )) C : \\ Users \\ user \\ accounts . txt C : \\ Users \\ user \\ details . csv C : \\ Users \\ user \\ invite . docx Using pathlib on *nix: >>> my_files = [ 'accounts.txt' , 'details.csv' , 'invite.docx' ] >>> home = Path . home () >>> for filename in my_files : >>> print ( home / filename ) / home / user / accounts . txt / home / user / details . csv / home / user / invite . docx The Current Working Directory Using os on Windows: >>> import os >>> os . getcwd () 'C: \\\\ Python34' >>> os . chdir ( 'C: \\\\ Windows \\\\ System32' ) >>> os . getcwd () 'C: \\\\ Windows \\\\ System32' Using pathlib on *nix: >>> from pathlib import Path >>> from os import chdir >>> print ( Path . cwd ()) / home / user >>> chdir ( '/usr/lib/python3.6' ) >>> print ( Path . cwd ()) / usr / lib / python3 .6 Creating New Folders Using os on Windows: >>> import os >>> os . makedirs ( 'C: \\\\ delicious \\\\ walnut \\\\ waffles' ) Using pathlib on *nix: >>> from pathlib import Path >>> cwd = Path . cwd () >>> ( cwd / 'delicious' / 'walnut' / 'waffles' ) . mkdir () Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/lib/python3.6/pathlib.py\" , line 1226 , in mkdir self . _accessor . mkdir ( self , mode ) File \"/usr/lib/python3.6/pathlib.py\" , line 387 , in wrapped return strfunc ( str ( pathobj ), * args ) FileNotFoundError : [ Errno 2 ] No such file or directory : '/home/user/delicious/walnut/waffles' Oh no, we got a nasty error! The reason is that the 'delicious' directory does not exist, so we cannot make the 'walnut' and the 'waffles' directories under it. To fix this, do: >>> from pathlib import Path >>> cwd = Path . cwd () >>> ( cwd / 'delicious' / 'walnut' / 'waffles' ) . mkdir ( parents = True ) And all is good :) Absolute vs. Relative Paths There are two ways to specify a file path. An absolute path, which always begins with the root folder A relative path, which is relative to the program\u2019s current working directory There are also the dot (.) and dot-dot (..) folders. These are not real folders but special names that can be used in a path. A single period (\u201cdot\u201d) for a folder name is shorthand for \u201cthis directory.\u201d Two periods (\u201cdot-dot\u201d) means \u201cthe parent folder.\u201d Handling Absolute and Relative Paths To see if a path is an absolute path: Using os.path on *nix: >>> import os >>> os . path . isabs ( '/' ) True >>> os . path . isabs ( '..' ) False Using pathlib on *nix: >>> from pathlib import Path >>> Path ( '/' ) . is_absolute () True >>> Path ( '..' ) . is_absolute () False You can extract an absolute path with both os.path and pathlib Using os.path on *nix: >>> import os >>> os . getcwd () '/home/user' >>> os . path . abspath ( '..' ) '/home' Using pathlib on *nix: from pathlib import Path print ( Path . cwd ()) / home / user print ( Path ( '..' ) . resolve ()) / home You can get a relative path from a starting path to another path. Using os.path on *nix: >>> import os >>> os . path . relpath ( '/etc/passwd' , '/' ) 'etc/passwd' Using pathlib on *nix: >>> from pathlib import Path >>> print ( Path ( '/etc/passwd' ) . relative_to ( '/' )) etc / passwd Checking Path Validity Checking if a file/directory exists: Using os.path on *nix: import os >>> os . path . exists ( '.' ) True >>> os . path . exists ( 'setup.py' ) True >>> os . path . exists ( '/etc' ) True >>> os . path . exists ( 'nonexistentfile' ) False Using pathlib on *nix: from pathlib import Path >>> Path ( '.' ) . exists () True >>> Path ( 'setup.py' ) . exists () True >>> Path ( '/etc' ) . exists () True >>> Path ( 'nonexistentfile' ) . exists () False Checking if a path is a file: Using os.path on *nix: >>> import os >>> os . path . isfile ( 'setup.py' ) True >>> os . path . isfile ( '/home' ) False >>> os . path . isfile ( 'nonexistentfile' ) False Using pathlib on *nix: >>> from pathlib import Path >>> Path ( 'setup.py' ) . is_file () True >>> Path ( '/home' ) . is_file () False >>> Path ( 'nonexistentfile' ) . is_file () False Checking if a path is a directory: Using os.path on *nix: >>> import os >>> os . path . isdir ( '/' ) True >>> os . path . isdir ( 'setup.py' ) False >>> os . path . isdir ( '/spam' ) False Using pathlib on *nix: >>> from pathlib import Path >>> Path ( '/' ) . is_dir () True >>> Path ( 'setup.py' ) . is_dir () False >>> Path ( '/spam' ) . is_dir () False Finding File Sizes and Folder Contents Getting a file's size in bytes: Using os.path on Windows: >>> import os >>> os . path . getsize ( 'C: \\\\ Windows \\\\ System32 \\\\ calc.exe' ) 776192 Using pathlib on *nix: >>> from pathlib import Path >>> stat = Path ( '/bin/python3.6' ) . stat () >>> print ( stat ) # stat contains some other information about the file as well os . stat_result ( st_mode = 33261 , st_ino = 141087 , st_dev = 2051 , st_nlink = 2 , st_uid = 0 , -- snip -- st_gid = 0 , st_size = 10024 , st_atime = 1517725562 , st_mtime = 1515119809 , st_ctime = 1517261276 ) >>> print ( stat . st_size ) # size in bytes 10024 Listing directory contents using os.listdir on Windows: >>> import os >>> os . listdir ( 'C: \\\\ Windows \\\\ System32' ) [ '0409' , '12520437.cpx' , '12520850.cpx' , '5U877.ax' , 'aaclient.dll' , -- snip -- 'xwtpdui.dll' , 'xwtpw32.dll' , 'zh-CN' , 'zh-HK' , 'zh-TW' , 'zipfldr.dll' ] Listing directory contents using pathlib on *nix: >>> from pathlib import Path >>> for f in Path ( '/usr/bin' ) . iterdir (): >>> print ( f ) ... / usr / bin / tiff2rgba / usr / bin / iconv / usr / bin / ldd / usr / bin / cache_restore / usr / bin / udiskie / usr / bin / unix2dos / usr / bin / t1reencode / usr / bin / epstopdf / usr / bin / idle3 ... To find the total size of all the files in this directory: WARNING : Directories themselves also have a size! So you might want to check for whether a path is a file or directory using the methods in the methods discussed in the above section! Using os.path.getsize() and os.listdir() together on Windows: >>> import os >>> total_size = 0 >>> for filename in os . listdir ( 'C: \\\\ Windows \\\\ System32' ): total_size = total_size + os . path . getsize ( os . path . join ( 'C: \\\\ Windows \\\\ System32' , filename )) >>> print ( total_size ) 1117846456 Using pathlib on *nix: >>> from pathlib import Path >>> total_size = 0 >>> for sub_path in Path ( '/usr/bin' ) . iterdir (): ... total_size += sub_path . stat () . st_size >>> >>> print ( total_size ) 1903178911 Copying Files and Folders The shutil module provides functions for copying files, as well as entire folders. >>> import shutil , os >>> os . chdir ( 'C: \\\\ ' ) >>> shutil . copy ( 'C: \\\\ spam.txt' , 'C: \\\\ delicious' ) 'C: \\\\ delicious \\\\ spam.txt' >>> shutil . copy ( 'eggs.txt' , 'C: \\\\ delicious \\\\ eggs2.txt' ) 'C: \\\\ delicious \\\\ eggs2.txt' While shutil.copy() will copy a single file, shutil.copytree() will copy an entire folder and every folder and file contained in it: >>> import shutil , os >>> os . chdir ( 'C: \\\\ ' ) >>> shutil . copytree ( 'C: \\\\ bacon' , 'C: \\\\ bacon_backup' ) 'C: \\\\ bacon_backup' Moving and Renaming Files and Folders >>> import shutil >>> shutil . move ( 'C: \\\\ bacon.txt' , 'C: \\\\ eggs' ) 'C: \\\\ eggs \\\\ bacon.txt' The destination path can also specify a filename. In the following example, the source file is moved and renamed: >>> shutil . move ( 'C: \\\\ bacon.txt' , 'C: \\\\ eggs \\\\ new_bacon.txt' ) 'C: \\\\ eggs \\\\ new_bacon.txt' If there is no eggs folder, then move() will rename bacon.txt to a file named eggs. >>> shutil . move ( 'C: \\\\ bacon.txt' , 'C: \\\\ eggs' ) 'C: \\\\ eggs' Permanently Deleting Files and Folders Calling os.unlink(path) or Path.unlink() will delete the file at path. Calling os.rmdir(path) or Path.rmdir() will delete the folder at path. This folder must be empty of any files or folders. Calling shutil.rmtree(path) will remove the folder at path, and all files and folders it contains will also be deleted. Safe Deletes with the send2trash Module You can install this module by running pip install send2trash from a Terminal window. >>> import send2trash >>> with open ( 'bacon.txt' , 'a' ) as bacon_file : # creates the file ... bacon_file . write ( 'Bacon is not a vegetable.' ) 25 >>> send2trash . send2trash ( 'bacon.txt' ) Walking a Directory Tree >>> import os >>> >>> for folder_name , subfolders , filenames in os . walk ( 'C: \\\\ delicious' ): >>> print ( 'The current folder is {} ' . format ( folder_name )) >>> >>> for subfolder in subfolders : >>> print ( 'SUBFOLDER OF {} : {} ' . format ( folder_name , subfolder )) >>> for filename in filenames : >>> print ( 'FILE INSIDE {} : {} ' . format ( folder_name , filename )) >>> >>> print ( '' ) The current folder is C : \\ delicious SUBFOLDER OF C : \\ delicious : cats SUBFOLDER OF C : \\ delicious : walnut FILE INSIDE C : \\ delicious : spam . txt The current folder is C : \\ delicious \\ cats FILE INSIDE C : \\ delicious \\ cats : catnames . txt FILE INSIDE C : \\ delicious \\ cats : zophie . jpg The current folder is C : \\ delicious \\ walnut SUBFOLDER OF C : \\ delicious \\ walnut : waffles The current folder is C : \\ delicious \\ walnut \\ waffles FILE INSIDE C : \\ delicious \\ walnut \\ waffles : butter . txt pathlib provides a lot more functionality than the ones listed above, like getting file name, getting file extension, reading/writing a file without manually opening it, etc. Check out the official documentation if you want to know more! Reading and Writing Files The File Reading/Writing Process To read/write to a file in Python, you will want to use the with statement, which will close the file for you after you are done. Opening and reading files with the open() function >>> with open ( 'C: \\\\ Users \\\\ your_home_folder \\\\ hello.txt' ) as hello_file : ... hello_content = hello_file . read () >>> hello_content 'Hello World!' >>> # Alternatively, you can use the *readlines()* method to get a list of string values from the file, one string for each line of text: >>> with open ( 'sonnet29.txt' ) as sonnet_file : ... sonnet_file . readlines () [ When , in disgrace with fortune and men 's eyes, \\n ' , ' I all alone beweep my outcast state , \\ n ', And trouble deaf heaven with my bootless cries, \\n ' , And look upon myself and curse my fate , '] >>> # You can also iterate through the file line by line: >>> with open ( 'sonnet29.txt' ) as sonnet_file : ... for line in sonnet_file : # note the new line character will be included in the line ... print ( line , end = '' ) When , in disgrace with fortune and men 's eyes, I all alone beweep my outcast state , And trouble deaf heaven with my bootless cries , And look upon myself and curse my fate , Writing to Files >>> with open ( 'bacon.txt' , 'w' ) as bacon_file : ... bacon_file . write ( 'Hello world! \\n ' ) 13 >>> with open ( 'bacon.txt' , 'a' ) as bacon_file : ... bacon_file . write ( 'Bacon is not a vegetable.' ) 25 >>> with open ( 'bacon.txt' ) as bacon_file : ... content = bacon_file . read () >>> print ( content ) Hello world ! Bacon is not a vegetable . Saving Variables with the shelve Module To save variables: >>> import shelve >>> cats = [ 'Zophie' , 'Pooka' , 'Simon' ] >>> with shelve . open ( 'mydata' ) as shelf_file : ... shelf_file [ 'cats' ] = cats To open and read variables: >>> with shelve . open ( 'mydata' ) as shelf_file : ... print ( type ( shelf_file )) ... print ( shelf_file [ 'cats' ]) < class ' shelve . DbfilenameShelf '> [ 'Zophie' , 'Pooka' , 'Simon' ] Just like dictionaries, shelf values have keys() and values() methods that will return list-like values of the keys and values in the shelf. Since these methods return list-like values instead of true lists, you should pass them to the list() function to get them in list form. >>> with shelve . open ( 'mydata' ) as shelf_file : ... print ( list ( shelf_file . keys ())) ... print ( list ( shelf_file . values ())) [ 'cats' ] [[ 'Zophie' , 'Pooka' , 'Simon' ]] Saving Variables with the pprint.pformat() Function >>> import pprint >>> cats = [{ 'name' : 'Zophie' , 'desc' : 'chubby' }, { 'name' : 'Pooka' , 'desc' : 'fluffy' }] >>> pprint . pformat ( cats ) \"[{'desc': 'chubby', 'name': 'Zophie'}, {'desc': 'fluffy', 'name': 'Pooka'}]\" >>> with open ( 'myCats.py' , 'w' ) as file_obj : ... file_obj . write ( 'cats = {} \\n ' . format ( pprint . pformat ( cats ))) 83 Reading ZIP Files >>> import zipfile , os >>> os . chdir ( 'C: \\\\ ' ) # move to the folder with example.zip >>> with zipfile . ZipFile ( 'example.zip' ) as example_zip : ... print ( example_zip . namelist ()) ... spam_info = example_zip . getinfo ( 'spam.txt' ) ... print ( spam_info . file_size ) ... print ( spam_info . compress_size ) ... print ( 'Compressed file is %s x smaller!' % ( round ( spam_info . file_size / spam_info . compress_size , 2 ))) [ 'spam.txt' , 'cats/' , 'cats/catnames.txt' , 'cats/zophie.jpg' ] 13908 3828 'Compressed file is 3.63x smaller!' Extracting from ZIP Files The extractall() method for ZipFile objects extracts all the files and folders from a ZIP file into the current working directory. >>> import zipfile , os >>> os . chdir ( 'C: \\\\ ' ) # move to the folder with example.zip >>> with zipfile . ZipFile ( 'example.zip' ) as example_zip : ... example_zip . extractall () The extract() method for ZipFile objects will extract a single file from the ZIP file. Continue the interactive shell example: >>> with zipfile . ZipFile ( 'example.zip' ) as example_zip : ... print ( example_zip . extract ( 'spam.txt' )) ... print ( example_zip . extract ( 'spam.txt' , 'C: \\\\ some \\\\ new \\\\ folders' )) 'C: \\\\ spam.txt' 'C: \\\\ some \\\\ new \\\\ folders \\\\ spam.txt' Creating and Adding to ZIP Files >>> import zipfile >>> with zipfile . ZipFile ( 'new.zip' , 'w' ) as new_zip : ... new_zip . write ( 'spam.txt' , compress_type = zipfile . ZIP_DEFLATED ) This code will create a new ZIP file named new.zip that has the compressed contents of spam.txt. JSON, YAML and configuration files JSON Open a JSON file with: import json with open ( \"filename.json\" , \"r\" ) as f : content = json . loads ( f . read ()) Write a JSON file with: import json content = { \"name\" : \"Joe\" , \"age\" : 20 } with open ( \"filename.json\" , \"w\" ) as f : f . write ( json . dumps ( content , indent = 2 )) YAML Compared to JSON, YAML allows for much better human maintainability and gives you the option to add comments. It is a convenient choice for configuration files where humans will have to edit it. There are two main libraries allowing to access to YAML files: PyYaml Ruamel.yaml Install them using pip install in your [[#Virtual Environment|virtual environment]] The first one it easier to use but the second one, Ruamel, implements much better the YAML specification, and allow for example to modify a YAML content without altering comments. Open a YAML file with: from ruamel.yaml import YAML with open ( \"filename.yaml\" ) as f : yaml = YAML () yaml . load ( f ) Anyconfig Anyconfig is a very handy package allowing to abstract completely the underlying configuration file format. It allows to load a Python dictionary from JSON, YAML, TOML, and so on. Install it with: pip install anyconfig Usage: import anyconfig conf1 = anyconfig . load ( \"/path/to/foo/conf.d/a.yml\" ) Debugging Raising Exceptions Exceptions are raised with a raise statement. In code, a raise statement consists of the following: The raise keyword A call to the Exception() function A string with a helpful error message passed to the Exception() function >>> raise Exception ( 'This is the error message.' ) Traceback ( most recent call last ): File \"<pyshell#191>\" , line 1 , in < module > raise Exception ( 'This is the error message.' ) Exception : This is the error message . Often it\u2019s the code that calls the function, not the function itself, that knows how to handle an exception. So you will commonly see a raise statement inside a function and the try and except statements in the code calling the function. def box_print ( symbol , width , height ): if len ( symbol ) != 1 : raise Exception ( 'Symbol must be a single character string.' ) if width <= 2 : raise Exception ( 'Width must be greater than 2.' ) if height <= 2 : raise Exception ( 'Height must be greater than 2.' ) print ( symbol * width ) for i in range ( height - 2 ): print ( symbol + ( ' ' * ( width - 2 )) + symbol ) print ( symbol * width ) for sym , w , h in (( '*' , 4 , 4 ), ( 'O' , 20 , 5 ), ( 'x' , 1 , 3 ), ( 'ZZ' , 3 , 3 )): try : box_print ( sym , w , h ) except Exception as err : print ( 'An exception happened: ' + str ( err )) Getting the Traceback as a String The traceback is displayed by Python whenever a raised exception goes unhandled. But can also obtain it as a string by calling traceback.format_exc(). This function is useful if you want the information from an exception\u2019s traceback but also want an except statement to gracefully handle the exception. You will need to import Python\u2019s traceback module before calling this function. >>> import traceback >>> try : >>> raise Exception ( 'This is the error message.' ) >>> except : >>> with open ( 'errorInfo.txt' , 'w' ) as error_file : >>> error_file . write ( traceback . format_exc ()) >>> print ( 'The traceback info was written to errorInfo.txt.' ) 116 The traceback info was written to errorInfo . txt . The 116 is the return value from the write() method, since 116 characters were written to the file. The traceback text was written to errorInfo.txt. Traceback ( most recent call last ): File \"<pyshell#28>\" , line 2 , in < module > Exception : This is the error message . Assertions An assertion is a sanity check to make sure your code isn\u2019t doing something obviously wrong. These sanity checks are performed by assert statements. If the sanity check fails, then an AssertionError exception is raised. In code, an assert statement consists of the following: The assert keyword A condition (that is, an expression that evaluates to True or False) A comma A string to display when the condition is False >>> pod_bay_door_status = 'open' >>> assert pod_bay_door_status == 'open' , 'The pod bay doors need to be \"open\".' >>> pod_bay_door_status = 'I \\' m sorry, Dave. I \\' m afraid I can \\' t do that.' >>> assert pod_bay_door_status == 'open' , 'The pod bay doors need to be \"open\".' Traceback ( most recent call last ): File \"<pyshell#10>\" , line 1 , in < module > assert pod_bay_door_status == 'open' , 'The pod bay doors need to be \"open\".' AssertionError : The pod bay doors need to be \"open\" . In plain English, an assert statement says, \u201cI assert that this condition holds true, and if not, there is a bug somewhere in the program.\u201d Unlike exceptions, your code should not handle assert statements with try and except; if an assert fails, your program should crash. By failing fast like this, you shorten the time between the original cause of the bug and when you first notice the bug. This will reduce the amount of code you will have to check before finding the code that\u2019s causing the bug. Disabling Assertions Assertions can be disabled by passing the -O option when running Python. Logging To enable the logging module to display log messages on your screen as your program runs, copy the following to the top of your program (but under the #! python shebang line): import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s - %(levelname)s - %(message)s ' ) Say you wrote a function to calculate the factorial of a number. In mathematics, factorial 4 is 1 \u00d7 2 \u00d7 3 \u00d7 4, or 24. Factorial 7 is 1 \u00d7 2 \u00d7 3 \u00d7 4 \u00d7 5 \u00d7 6 \u00d7 7, or 5,040. Open a new file editor window and enter the following code. It has a bug in it, but you will also enter several log messages to help yourself figure out what is going wrong. Save the program as factorialLog.py. >>> import logging >>> >>> logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s - %(levelname)s - %(message)s ' ) >>> >>> logging . debug ( 'Start of program' ) >>> >>> def factorial ( n ): >>> >>> logging . debug ( 'Start of factorial( %s )' % ( n )) >>> total = 1 >>> >>> for i in range ( 1 , n + 1 ): >>> total *= i >>> logging . debug ( 'i is ' + str ( i ) + ', total is ' + str ( total )) >>> >>> logging . debug ( 'End of factorial( %s )' % ( n )) >>> >>> return total >>> >>> print ( factorial ( 5 )) >>> logging . debug ( 'End of program' ) 2015 - 05 - 23 16 : 20 : 12 , 664 - DEBUG - Start of program 2015 - 05 - 23 16 : 20 : 12 , 664 - DEBUG - Start of factorial ( 5 ) 2015 - 05 - 23 16 : 20 : 12 , 665 - DEBUG - i is 0 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 668 - DEBUG - i is 1 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 670 - DEBUG - i is 2 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 673 - DEBUG - i is 3 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 675 - DEBUG - i is 4 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 678 - DEBUG - i is 5 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 680 - DEBUG - End of factorial ( 5 ) 0 2015 - 05 - 23 16 : 20 : 12 , 684 - DEBUG - End of program Logging Levels Logging levels provide a way to categorize your log messages by importance. There are five logging levels, described in Table 10-1 from least to most important. Messages can be logged at each level using a different logging function. Level Logging Function Description DEBUG logging.debug() The lowest level. Used for small details. Usually you care about these messages only when diagnosing problems. INFO logging.info() Used to record information on general events in your program or confirm that things are working at their point in the program. WARNING logging.warning() Used to indicate a potential problem that doesn't prevent the program from working but might do so in the future. ERROR logging.error() Used to record an error that caused the program to fail to do something. CRITICAL logging.critical() The highest level. Used to indicate a fatal error that has caused or is about to cause the program to stop running entirely. Disabling Logging After you\u2019ve debugged your program, you probably don\u2019t want all these log messages cluttering the screen. The logging.disable() function disables these so that you don\u2019t have to go into your program and remove all the logging calls by hand. >>> import logging >>> logging . basicConfig ( level = logging . INFO , format = ' %(asctime)s - %(levelname)s - %(message)s ' ) >>> logging . critical ( 'Critical error! Critical error!' ) 2015 - 05 - 22 11 : 10 : 48 , 054 - CRITICAL - Critical error ! Critical error ! >>> logging . disable ( logging . CRITICAL ) >>> logging . critical ( 'Critical error! Critical error!' ) >>> logging . error ( 'Error! Error!' ) Logging to a File Instead of displaying the log messages to the screen, you can write them to a text file. The logging.basicConfig() function takes a filename keyword argument, like so: import logging logging . basicConfig ( filename = 'myProgramLog.txt' , level = logging . DEBUG , format = ' %(asctime)s - %(levelname)s - %(message)s ' ) Lambda Functions This function: >>> def add ( x , y ): return x + y >>> add ( 5 , 3 ) 8 Is equivalent to the lambda function: >>> add = lambda x , y : x + y >>> add ( 5 , 3 ) 8 It's not even need to bind it to a name like add before: >>> ( lambda x , y : x + y )( 5 , 3 ) 8 Like regular nested functions, lambdas also work as lexical closures: >>> def make_adder ( n ): return lambda x : x + n >>> plus_3 = make_adder ( 3 ) >>> plus_5 = make_adder ( 5 ) >>> plus_3 ( 4 ) 7 >>> plus_5 ( 4 ) 9 Note : lambda can only evaluate an expression, like a single line of code. Ternary Conditional Operator Many programming languages have a ternary operator, which define a conditional expression. The most common usage is to make a terse simple conditional assignment statement. In other words, it offers one-line code to evaluate the first expression if the condition is true, otherwise it evaluates the second expression. < expression1 > if < condition > else < expression2 > Example: >>> age = 15 >>> print ( 'kid' if age < 18 else 'adult' ) kid Ternary operators can be chained: >>> age = 15 >>> print ( 'kid' if age < 13 else 'teenager' if age < 18 else 'adult' ) teenager The code above is equivalent to: if age < 18 : if age < 13 : print ( 'kid' ) else : print ( 'teenager' ) else : print ( 'adult' ) args and kwargs The names args and kwargs are arbitrary - the important thing are the * and ** operators. They can mean: In a function declaration, * means \u201cpack all remaining positional arguments into a tuple named <name> \u201d, while ** is the same for keyword arguments (except it uses a dictionary, not a tuple). In a function call, * means \u201cunpack tuple or list named <name> to positional arguments at this position\u201d, while ** is the same for keyword arguments. For example you can make a function that you can use to call any other function, no matter what parameters it has: def forward ( f , * args , ** kwargs ): return f ( * args , ** kwargs ) Inside forward, args is a tuple (of all positional arguments except the first one, because we specified it - the f), kwargs is a dict. Then we call f and unpack them so they become normal arguments to f. You use *args when you have an indefinite amount of positional arguments. >>> def fruits ( * args ): >>> for fruit in args : >>> print ( fruit ) >>> fruits ( \"apples\" , \"bananas\" , \"grapes\" ) \"apples\" \"bananas\" \"grapes\" Similarly, you use **kwargs when you have an indefinite number of keyword arguments. >>> def fruit ( ** kwargs ): >>> for key , value in kwargs . items (): >>> print ( \" {0} : {1} \" . format ( key , value )) >>> fruit ( name = \"apple\" , color = \"red\" ) name : apple color : red >>> def show ( arg1 , arg2 , * args , kwarg1 = None , kwarg2 = None , ** kwargs ): >>> print ( arg1 ) >>> print ( arg2 ) >>> print ( args ) >>> print ( kwarg1 ) >>> print ( kwarg2 ) >>> print ( kwargs ) >>> data1 = [ 1 , 2 , 3 ] >>> data2 = [ 4 , 5 , 6 ] >>> data3 = { 'a' : 7 , 'b' : 8 , 'c' : 9 } >>> show ( * data1 , * data2 , kwarg1 = \"python\" , kwarg2 = \"cheatsheet\" , ** data3 ) 1 2 ( 3 , 4 , 5 , 6 ) python cheatsheet { 'a' : 7 , 'b' : 8 , 'c' : 9 } >>> show ( * data1 , * data2 , ** data3 ) 1 2 ( 3 , 4 , 5 , 6 ) None None { 'a' : 7 , 'b' : 8 , 'c' : 9 } # If you do not specify ** for kwargs >>> show ( * data1 , * data2 , * data3 ) 1 2 ( 3 , 4 , 5 , 6 , \"a\" , \"b\" , \"c\" ) None None {} Things to Remember(args) Functions can accept a variable number of positional arguments by using *args in the def statement. You can use the items from a sequence as the positional arguments for a function with the * operator. Using the * operator with a generator may cause your program to run out of memory and crash. Adding new positional parameters to functions that accept *args can introduce hard-to-find bugs. Things to Remember(kwargs) Function arguments can be specified by position or by keyword. Keywords make it clear what the purpose of each argument is when it would be confusing with only positional arguments. Keyword arguments with default values make it easy to add new behaviors to a function, especially when the function has existing callers. Optional keyword arguments should always be passed by keyword instead of by position. Context Manager While Python's context managers are widely used, few understand the purpose behind their use. These statements, commonly used with reading and writing files, assist the application in conserving system memory and improve resource management by ensuring specific resources are only in use for certain processes. with statement A context manager is an object that is notified when a context (a block of code) starts and ends. You commonly use one with the with statement. It takes care of the notifying. For example, file objects are context managers. When a context ends, the file object is closed automatically: >>> with open ( filename ) as f : >>> file_contents = f . read () # the open_file object has automatically been closed. Anything that ends execution of the block causes the context manager's exit method to be called. This includes exceptions, and can be useful when an error causes you to prematurely exit from an open file or connection. Exiting a script without properly closing files/connections is a bad idea, that may cause data loss or other problems. By using a context manager you can ensure that precautions are always taken to prevent damage or loss in this way. Writing your own contextmanager using generator syntax It is also possible to write a context manager using generator syntax thanks to the contextlib.contextmanager decorator: >>> import contextlib >>> @contextlib . contextmanager ... def context_manager ( num ): ... print ( 'Enter' ) ... yield num + 1 ... print ( 'Exit' ) >>> with context_manager ( 2 ) as cm : ... # the following instructions are run when the 'yield' point of the context ... # manager is reached. ... # 'cm' will have the value that was yielded ... print ( 'Right in the middle with cm = {} ' . format ( cm )) Enter Right in the middle with cm = 3 Exit >>> __main__ Top-level script environment __main__ is the name of the scope in which top-level code executes. A module\u2019s name is set equal to __main__ when read from standard input, a script, or from an interactive prompt. A module can discover whether or not it is running in the main scope by checking its own __name__ , which allows a common idiom for conditionally executing code in a module when it is run as a script or with python -m but not when it is imported: >>> if __name__ == \"__main__\" : ... # execute only if run as a script ... main () For a package, the same effect can be achieved by including a main .py module, the contents of which will be executed when the module is run with -m For example we are developing script which is designed to be used as module, we should do: >>> # Python program to execute function directly >>> def add ( a , b ): ... return a + b ... >>> add ( 10 , 20 ) # we can test it by calling the function save it as calculate.py 30 >>> # Now if we want to use that module by importing we have to comment out our call, >>> # Instead we can write like this in calculate.py >>> if __name__ == \"__main__\" : ... add ( 3 , 5 ) ... >>> import calculate >> 8 Advantages Every Python module has it\u2019s __name__ defined and if this is __main__ , it implies that the module is being run standalone by the user and we can do corresponding appropriate actions. If you import this script as a module in another script, the name is set to the name of the script/module. Python files can act as either reusable modules, or as standalone programs. if __name__ == \u201cmain\u201d: is used to execute some code only if the file was run directly, and not imported. setup.py The setup script is the centre of all activity in building, distributing, and installing modules using the Distutils. The main purpose of the setup script is to describe your module distribution to the Distutils, so that the various commands that operate on your modules do the right thing. The setup.py file is at the heart of a Python project. It describes all of the metadata about your project. There a quite a few fields you can add to a project to give it a rich set of metadata describing the project. However, there are only three required fields: name, version, and packages. The name field must be unique if you wish to publish your package on the Python Package Index (PyPI). The version field keeps track of different releases of the project. The packages field describes where you\u2019ve put the Python source code within your project. This allows you to easily install Python packages. Often it's enough to write: python setup . py install and module will install itself. Our initial setup.py will also include information about the license and will re-use the README.txt file for the long_description field. This will look like: >>> from distutils.core import setup >>> setup ( ... name = 'pythonCheatsheet' , ... version = '0.1' , ... packages = [ 'pipenv' ,], ... license = 'MIT' , ... long_description = open ( 'README.txt' ) . read (), ... ) Find more information visit http://docs.python.org/install/index.html . Dataclasses Dataclasses are python classes but are suited for storing data objects. This module provides a decorator and functions for automatically adding generated special methods such as __init__() and __repr__() to user-defined classes. Features They store data and represent a certain data type. Ex: A number. For people familiar with ORMs, a model instance is a data object. It represents a specific kind of entity. It holds attributes that define or represent the entity. They can be compared to other objects of the same type. Ex: A number can be greater than, less than, or equal to another number. Python 3.7 provides a decorator dataclass that is used to convert a class into a dataclass. python 2.7 >>> class Number : ... def __init__ ( self , val ): ... self . val = val ... >>> obj = Number ( 2 ) >>> obj . val 2 with dataclass >>> @dataclass ... class Number : ... val : int ... >>> obj = Number ( 2 ) >>> obj . val 2 Default values It is easy to add default values to the fields of your data class. >>> @dataclass ... class Product : ... name : str ... count : int = 0 ... price : float = 0.0 ... >>> obj = Product ( \"Python\" ) >>> obj . name Python >>> obj . count 0 >>> obj . price 0.0 Type hints It is mandatory to define the data type in dataclass. However, If you don't want specify the datatype then, use typing.Any . >>> from dataclasses import dataclass >>> from typing import Any >>> @dataclass ... class WithoutExplicitTypes : ... name : Any ... value : Any = 42 ... Virtual Environment The use of a Virtual Environment is to test python code in encapsulated environments and to also avoid filling the base Python installation with libraries we might use for only one project. virtualenv Install virtualenv pip install virtualenv Install virtualenvwrapper-win (Windows) pip install virtualenvwrapper-win Usage : Make a Virtual Environment mkvirtualenv HelloWold Anything we install now will be specific to this project. And available to the projects we connect to this environment. Set Project Directory To bind our virtualenv with our current working directory we simply enter: setprojectdir . Deactivate To move onto something else in the command line type \u2018deactivate\u2019 to deactivate your environment. deactivate Notice how the parenthesis disappear. Workon Open up the command prompt and type \u2018workon HelloWold\u2019 to activate the environment and move into your root project folder workon HelloWold poetry [Poetry](https://poetry.eustace.io/) is a tool for dependency management and packaging in Python. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you. Install Poetry pip install --user poetry Create a new project poetry new my-project This will create a my-project directory: my-project \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.rst \u251c\u2500\u2500 poetry_demo \u2502 \u2514\u2500\u2500 __init__.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_demo.py The pyproject.toml file will orchestrate your project and its dependencies: [tool.poetry] name = \"my-project\" version = \"0.1.0\" description = \"\" authors = [ \"your name <your@mail.com>\" ] [tool.poetry.dependencies] python = \"*\" [tool.poetry.dev-dependencies] pytest = \"^3.4\" Packages To add dependencies to your project, you can specify them in the tool.poetry.dependencies section: [tool.poetry.dependencies] pendulum = \"^1.4\" Also, instead of modifying the pyproject.toml file by hand, you can use the add command and it will automatically find a suitable version constraint. $ poetry add pendulum To install the dependencies listed in the pyproject.toml: poetry install To remove dependencies: poetry remove pendulum For more information, check the documentation . pipenv [Pipenv](https://pipenv.readthedocs.io/en/latest/) is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. Windows is a first-class citizen, in our world. Install pipenv pip install pipenv Enter your Project directory and install the Packages for your project cd my_project pipenv install <package> Pipenv will install your package and create a Pipfile for you in your project\u2019s directory. The Pipfile is used to track which dependencies your project needs in case you need to re-install them. Uninstall Packages pipenv uninstall <package> Activate the Virtual Environment associated with your Python project pipenv shell Exit the Virtual Environment exit Find more information and a video in docs.pipenv.org . anaconda Anaconda is another popular tool to manage python packages. Where packages, notebooks, projects and environments are shared. Your place for free public conda package hosting. Usage: Make a Virtual Environment conda create -n HelloWorld To use the Virtual Environment, activate it by: conda activate HelloWorld Anything installed now will be specific to the project HelloWorld Exit the Virtual Environment conda deactivate","title":"Python Programming"},{"location":"Python/#python-cheatsheet","text":"This is a comprehensive list of all the basics of Python. Inspired by pythoncheatsheet.org","title":"Python Cheatsheet"},{"location":"Python/#the-zen-of-python","text":"Long time Pythoneer Tim Peters succinctly channels the BDFL's guiding principles for Python's design into 20 aphorisms, only 19 of which have been written down. The Zen of Python , by Tim Peters Beautiful is better than ugly . Explicit is better than implicit . Simple is better than complex . Complex is better than complicated . Flat is better than nested . Sparse is better than dense . Readability counts . Special cases aren 't special enough to break the rules. Although practicality beats purity . Errors should never pass silently . Unless explicitly silenced . In the face of ambiguity , refuse the temptation to guess . There should be one -- and preferably only one -- obvious way to do it . Although that way may not be obvious at first unless you 're Dutch. Now is better than never . Although never is often better than * right * now . If the implementation is hard to explain , it 's a bad idea. If the implementation is easy to explain , it may be a good idea . Namespaces are one fucking great idea -- let 's do more of those!","title":"The Zen of Python"},{"location":"Python/#python-basics","text":"","title":"Python Basics"},{"location":"Python/#math-operators","text":"Operators Operation Example ** Exponent 2 ** 3 = 8 % Modulus/Remainder 22 % 8 = 6 // Integer division 22 // 8 = 2 / Division 22 / 8 = 2.75 * Multiplication 3 * 3 = 9 - Subtraction 5 - 2 = 3 + Addition 2 + 2 = 4","title":"Math Operators"},{"location":"Python/#data-types","text":"Data Type Examples Integers -2, -1, 0, 1, 2, 3, 4, 5 Floating-point numbers -1.25, -1.0, --0.5, 0.0, 0.5, 1.0, 1.25 Strings 'a', 'aa', 'aaa', 'Hello!', '11 cats'","title":"Data Types"},{"location":"Python/#variables","text":"You can name a variable anything as long as it obeys the following rules: It can only be one word. It can use only letters, numbers, and the underscore (_) character. It can't begin with a number. Variable name starting with an underscore (_) are considered as \"unuseful\". Example: >>> spam = \"Hello\" >>> spam \"Hello\" >>> _spam = \"Hello\" _spam should not be used again in the code.","title":"Variables"},{"location":"Python/#comments","text":"Inline comment: # This is a comment Multiline comment: # This is a # multiline comment Code with a comment: a = 1 # initialization Function docstring: def foo (): \"\"\" This is a function docstring You can also user: ''' Function Docstring ''' \"\"\"","title":"Comments"},{"location":"Python/#the-print-function","text":"Example Code: >>> print ( 'What is your name?' ) # ask for their name >>> myName = input () >>> print ( 'It is good to meet you, {} ' . format ( myName )) What is your name ? Al It is good to meet you , Al","title":"The print() Function"},{"location":"Python/#the-len-function","text":"Evaluates to the integer value of the number of characters in a string: >>> len ( 'hello' ) 5 Note: test of emptiness of strings, lists, dictionary, etc, should not use len, but prefer direct boolean evaluation. >>> a = [ 1 , 2 , 3 ] >>> if a : >>> print ( \"the list is not empty!\" )","title":"The len() Function"},{"location":"Python/#the-str-int-and-float-functions","text":"Integer to String or Float: >>> str ( 29 ) '29' >>> print ( 'I am {} years old.' . format ( str ( 29 ))) I am 29 years old . >>> str ( - 3.14 ) '-3.14' Float to Integer: >>> int ( 7.7 ) 7 >>> int ( 7.7 ) + 1 8","title":"The str(), int() and float() Functions"},{"location":"Python/#flow-control","text":"","title":"Flow Control"},{"location":"Python/#comparison-operators","text":"Operator Meaning == Equal to != Not equal to < Less than > Greater than <= Less than or Equal to >= Greater than or Equal to These operators evaluate to True or False depending on the values you give them. Examples: >>> 42 == 42 True >>> 40 == 42 False >>> 'hello' == 'hello' True >>> 'hello' == 'Hello' False >>> 'dog' != 'cat' True >>> 42 == 42.0 True >>> 42 == '42' False","title":"Comparison Operators"},{"location":"Python/#boolean-evaluation","text":"Never use == or != operator to evaluate boolean operation. Use the is or is not operators, or use implicit boolean evaluation. NO (even if they are valid Python): >>> True == True True >>> True != False True YES (even if they are valid Python): >>> True is True True >>> True is not False True These statements are equivalent: >>> if a is True : >>> pass >>> if a is not False : >>> pass >>> if a : >>> pass And these as well: >>> if a is False : >>> pass >>> if a is not True : >>> pass >>> if not a : >>> pass","title":"Boolean evaluation"},{"location":"Python/#boolean-operators","text":"There are three Boolean operators: and, or, and not. The and Operator\u2019s Truth Table: Expression Evaluates to True and True True True and False False False and True False False and False False The or Operator\u2019s Truth Table: Expression Evaluates to True or True True True or False True False or True True False or False False The not Operator\u2019s Truth Table: Expression Evaluates to not True False not False True","title":"Boolean Operators"},{"location":"Python/#mixing-boolean-and-comparison-operators","text":">>> ( 4 < 5 ) and ( 5 < 6 ) True >>> ( 4 < 5 ) and ( 9 < 6 ) False >>> ( 1 == 2 ) or ( 2 == 2 ) True You can also use multiple Boolean operators in an expression, along with the comparison operators: >>> 2 + 2 == 4 and not 2 + 2 == 5 and 2 * 2 == 2 + 2 True","title":"Mixing Boolean and Comparison Operators"},{"location":"Python/#if-statements","text":"if name == 'Alice' : print ( 'Hi, Alice.' )","title":"if Statements"},{"location":"Python/#else-statements","text":"name = 'Bob' if name == 'Alice' : print ( 'Hi, Alice.' ) else : print ( 'Hello, stranger.' )","title":"else Statements"},{"location":"Python/#elif-statements","text":"name = 'Bob' age = 5 if name == 'Alice' : print ( 'Hi, Alice.' ) elif age < 12 : print ( 'You are not Alice, kiddo.' ) name = 'Bob' age = 30 if name == 'Alice' : print ( 'Hi, Alice.' ) elif age < 12 : print ( 'You are not Alice, kiddo.' ) else : print ( 'You are neither Alice nor a little kid.' )","title":"elif Statements"},{"location":"Python/#while-loop-statements","text":"spam = 0 while spam < 5 : print ( 'Hello, world.' ) spam = spam + 1","title":"while Loop Statements"},{"location":"Python/#break-statements","text":"If the execution reaches a break statement, it immediately exits the while loop\u2019s clause: while True : print ( 'Please type your name.' ) name = input () if name == 'your name' : break print ( 'Thank you!' )","title":"break Statements"},{"location":"Python/#continue-statements","text":"When the program execution reaches a continue statement, the program execution immediately jumps back to the start of the loop. while True : print ( 'Who are you?' ) name = input () if name != 'Joe' : continue print ( 'Hello, Joe. What is the password? (It is a fish.)' ) password = input () if password == 'swordfish' : break print ( 'Access granted.' )","title":"continue Statements"},{"location":"Python/#for-loops-and-the-range-function","text":">>> print ( 'My name is' ) >>> for i in range ( 5 ): >>> print ( 'Jimmy Five Times ( {} )' . format ( str ( i ))) My name is Jimmy Five Times ( 0 ) Jimmy Five Times ( 1 ) Jimmy Five Times ( 2 ) Jimmy Five Times ( 3 ) Jimmy Five Times ( 4 ) The range() function can also be called with three arguments. The first two arguments will be the start and stop values, and the third will be the step argument. The step is the amount that the variable is increased by after each iteration. >>> for i in range ( 0 , 10 , 2 ): >>> print ( i ) 0 2 4 6 8 You can even use a negative number for the step argument to make the for loop count down instead of up. >>> for i in range ( 5 , - 1 , - 1 ): >>> print ( i ) 5 4 3 2 1 0","title":"for Loops and the range() Function"},{"location":"Python/#for-else-statement","text":"This allows to specify a statement to execute in case of the full loop has been executed. Only useful when a break condition can occur in the loop: >>> for i in [ 1 , 2 , 3 , 4 , 5 ]: >>> if i == 3 : >>> break >>> else : >>> print ( \"only executed when no item of the list is equal to 3\" )","title":"For else statement"},{"location":"Python/#importing-modules","text":"import random for i in range ( 5 ): print ( random . randint ( 1 , 10 )) import random , sys , os , math from random import *","title":"Importing Modules"},{"location":"Python/#ending-a-program-early-with-sysexit","text":"import sys while True : print ( 'Type exit to exit.' ) response = input () if response == 'exit' : sys . exit () print ( 'You typed {} .' . format ( response ))","title":"Ending a Program Early with sys.exit()"},{"location":"Python/#functions","text":">>> def hello ( name ): >>> print ( 'Hello {} ' . format ( name )) >>> >>> hello ( 'Alice' ) >>> hello ( 'Bob' ) Hello Alice Hello Bob","title":"Functions"},{"location":"Python/#return-values-and-return-statements","text":"When creating a function using the def statement, you can specify what the return value should be with a return statement. A return statement consists of the following: The return keyword. The value or expression that the function should return. import random def getAnswer ( answerNumber ): if answerNumber == 1 : return 'It is certain' elif answerNumber == 2 : return 'It is decidedly so' elif answerNumber == 3 : return 'Yes' elif answerNumber == 4 : return 'Reply hazy try again' elif answerNumber == 5 : return 'Ask again later' elif answerNumber == 6 : return 'Concentrate and ask again' elif answerNumber == 7 : return 'My reply is no' elif answerNumber == 8 : return 'Outlook not so good' elif answerNumber == 9 : return 'Very doubtful' r = random . randint ( 1 , 9 ) fortune = getAnswer ( r ) print ( fortune )","title":"Return Values and return Statements"},{"location":"Python/#the-none-value","text":">>> spam = print ( 'Hello!' ) Hello ! >>> spam is None True Note: never compare to None with the == operator. Always use is .","title":"The None Value"},{"location":"Python/#keyword-arguments-and-print","text":">>> print ( 'Hello' , end = '' ) >>> print ( 'World' ) HelloWorld >>> print ( 'cats' , 'dogs' , 'mice' ) cats dogs mice >>> print ( 'cats' , 'dogs' , 'mice' , sep = ',' ) cats , dogs , mice","title":"Keyword Arguments and print()"},{"location":"Python/#local-and-global-scope","text":"Code in the global scope cannot use any local variables. However, a local scope can access global variables. Code in a function\u2019s local scope cannot use variables in any other local scope. You can use the same name for different variables if they are in different scopes. That is, there can be a local variable named spam and a global variable also named spam.","title":"Local and Global Scope"},{"location":"Python/#the-global-statement","text":"If you need to modify a global variable from within a function, use the global statement: >>> def spam (): >>> global eggs >>> eggs = 'spam' >>> >>> eggs = 'global' >>> spam () >>> print ( eggs ) spam There are four rules to tell whether a variable is in a local scope or global scope: If a variable is being used in the global scope (that is, outside of all functions), then it is always a global variable. If there is a global statement for that variable in a function, it is a global variable. Otherwise, if the variable is used in an assignment statement in the function, it is a local variable. But if the variable is not used in an assignment statement, it is a global variable.","title":"The global Statement"},{"location":"Python/#exception-handling","text":"","title":"Exception Handling"},{"location":"Python/#basic-exception-handling","text":">>> def spam ( divideBy ): >>> try : >>> return 42 / divideBy >>> except ZeroDivisionError as e : >>> print ( 'Error: Invalid argument: {} ' . format ( e )) >>> >>> print ( spam ( 2 )) >>> print ( spam ( 12 )) >>> print ( spam ( 0 )) >>> print ( spam ( 1 )) 21.0 3.5 Error : Invalid argument : division by zero None 42.0","title":"Basic exception handling"},{"location":"Python/#final-code-in-exception-handling","text":"Code inside the finally section is always executed, no matter if an exception has been raised or not, and even if an exception is not caught. >>> def spam ( divideBy ): >>> try : >>> return 42 / divideBy >>> except ZeroDivisionError as e : >>> print ( 'Error: Invalid argument: {} ' . format ( e )) >>> finally : >>> print ( \"-- division finished --\" ) >>> print ( spam ( 2 )) -- division finished -- 21.0 >>> print ( spam ( 12 )) -- division finished -- 3.5 >>> print ( spam ( 0 )) Error : Invalid Argument division by zero -- division finished -- None >>> print ( spam ( 1 )) -- division finished -- 42.0","title":"Final code in exception handling"},{"location":"Python/#lists","text":">>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ 'cat' , 'bat' , 'rat' , 'elephant' ]","title":"Lists"},{"location":"Python/#getting-individual-values-in-a-list-with-indexes","text":">>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ 0 ] 'cat' >>> spam [ 1 ] 'bat' >>> spam [ 2 ] 'rat' >>> spam [ 3 ] 'elephant'","title":"Getting Individual Values in a List with Indexes"},{"location":"Python/#negative-indexes","text":">>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ - 1 ] 'elephant' >>> spam [ - 3 ] 'bat' >>> 'The {} is afraid of the {} .' . format ( spam [ - 1 ], spam [ - 3 ]) 'The elephant is afraid of the bat.'","title":"Negative Indexes"},{"location":"Python/#getting-sublists-with-slices","text":">>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ 0 : 4 ] [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ 1 : 3 ] [ 'bat' , 'rat' ] >>> spam [ 0 : - 1 ] [ 'cat' , 'bat' , 'rat' ] >>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [: 2 ] [ 'cat' , 'bat' ] >>> spam [ 1 :] [ 'bat' , 'rat' , 'elephant' ] Slicing the complete list will perform a copy: >>> spam2 = spam [:] [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam . append ( 'dog' ) >>> spam [ 'cat' , 'bat' , 'rat' , 'elephant' , 'dog' ] >>> spam2 [ 'cat' , 'bat' , 'rat' , 'elephant' ]","title":"Getting Sublists with Slices"},{"location":"Python/#getting-a-lists-length-with-len","text":">>> spam = [ 'cat' , 'dog' , 'moose' ] >>> len ( spam ) 3","title":"Getting a List\u2019s Length with len()"},{"location":"Python/#changing-values-in-a-list-with-indexes","text":">>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam [ 1 ] = 'aardvark' >>> spam [ 'cat' , 'aardvark' , 'rat' , 'elephant' ] >>> spam [ 2 ] = spam [ 1 ] >>> spam [ 'cat' , 'aardvark' , 'aardvark' , 'elephant' ] >>> spam [ - 1 ] = 12345 >>> spam [ 'cat' , 'aardvark' , 'aardvark' , 12345 ]","title":"Changing Values in a List with Indexes"},{"location":"Python/#list-concatenation-and-list-replication","text":">>> [ 1 , 2 , 3 ] + [ 'A' , 'B' , 'C' ] [ 1 , 2 , 3 , 'A' , 'B' , 'C' ] >>> [ 'X' , 'Y' , 'Z' ] * 3 [ 'X' , 'Y' , 'Z' , 'X' , 'Y' , 'Z' , 'X' , 'Y' , 'Z' ] >>> spam = [ 1 , 2 , 3 ] >>> spam = spam + [ 'A' , 'B' , 'C' ] >>> spam [ 1 , 2 , 3 , 'A' , 'B' , 'C' ]","title":"List Concatenation and List Replication"},{"location":"Python/#removing-values-from-lists-with-del-statements","text":">>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> del spam [ 2 ] >>> spam [ 'cat' , 'bat' , 'elephant' ] >>> del spam [ 2 ] >>> spam [ 'cat' , 'bat' ]","title":"Removing Values from Lists with del Statements"},{"location":"Python/#using-for-loops-with-lists","text":">>> supplies = [ 'pens' , 'staplers' , 'flame-throwers' , 'binders' ] >>> for i , supply in enumerate ( supplies ): >>> print ( 'Index {} in supplies is: {} ' . format ( str ( i ), supply )) Index 0 in supplies is : pens Index 1 in supplies is : staplers Index 2 in supplies is : flame - throwers Index 3 in supplies is : binders","title":"Using for Loops with Lists"},{"location":"Python/#looping-through-multiple-lists-with-zip","text":">>> name = [ 'Pete' , 'John' , 'Elizabeth' ] >>> age = [ 6 , 23 , 44 ] >>> for n , a in zip ( name , age ): >>> print ( ' {} is {} years old' . format ( n , a )) Pete is 6 years old John is 23 years old Elizabeth is 44 years old","title":"Looping Through Multiple Lists with zip()"},{"location":"Python/#the-in-and-not-in-operators","text":">>> 'howdy' in [ 'hello' , 'hi' , 'howdy' , 'heyas' ] True >>> spam = [ 'hello' , 'hi' , 'howdy' , 'heyas' ] >>> 'cat' in spam False >>> 'howdy' not in spam False >>> 'cat' not in spam True","title":"The in and not in Operators"},{"location":"Python/#the-multiple-assignment-trick","text":"The multiple assignment trick is a shortcut that lets you assign multiple variables with the values in a list in one line of code. So instead of doing this: >>> cat = [ 'fat' , 'orange' , 'loud' ] >>> size = cat [ 0 ] >>> color = cat [ 1 ] >>> disposition = cat [ 2 ] You could type this line of code: >>> cat = [ 'fat' , 'orange' , 'loud' ] >>> size , color , disposition = cat The multiple assignment trick can also be used to swap the values in two variables: >>> a , b = 'Alice' , 'Bob' >>> a , b = b , a >>> print ( a ) 'Bob' >>> print ( b ) 'Alice'","title":"The Multiple Assignment Trick"},{"location":"Python/#augmented-assignment-operators","text":"Operator Equivalent spam += 1 spam = spam + 1 spam -= 1 spam = spam - 1 spam *= 1 spam = spam * 1 spam /= 1 spam = spam / 1 spam %= 1 spam = spam % 1 Examples: >>> spam = 'Hello' >>> spam += ' world!' >>> spam 'Hello world!' >>> bacon = [ 'Zophie' ] >>> bacon *= 3 >>> bacon [ 'Zophie' , 'Zophie' , 'Zophie' ]","title":"Augmented Assignment Operators"},{"location":"Python/#finding-a-value-in-a-list-with-the-index-method","text":">>> spam = [ 'Zophie' , 'Pooka' , 'Fat-tail' , 'Pooka' ] >>> spam . index ( 'Pooka' ) 1","title":"Finding a Value in a List with the index() Method"},{"location":"Python/#adding-values-to-lists-with-the-append-and-insert-methods","text":"append() : >>> spam = [ 'cat' , 'dog' , 'bat' ] >>> spam . append ( 'moose' ) >>> spam [ 'cat' , 'dog' , 'bat' , 'moose' ] insert() : >>> spam = [ 'cat' , 'dog' , 'bat' ] >>> spam . insert ( 1 , 'chicken' ) >>> spam [ 'cat' , 'chicken' , 'dog' , 'bat' ]","title":"Adding Values to Lists with the append() and insert() Methods"},{"location":"Python/#removing-values-from-lists-with-remove","text":">>> spam = [ 'cat' , 'bat' , 'rat' , 'elephant' ] >>> spam . remove ( 'bat' ) >>> spam [ 'cat' , 'rat' , 'elephant' ] If the value appears multiple times in the list, only the first instance of the value will be removed.","title":"Removing Values from Lists with remove()"},{"location":"Python/#sorting-the-values-in-a-list-with-the-sort-method","text":">>> spam = [ 2 , 5 , 3.14 , 1 , - 7 ] >>> spam . sort () >>> spam [ - 7 , 1 , 2 , 3.14 , 5 ] >>> spam = [ 'ants' , 'cats' , 'dogs' , 'badgers' , 'elephants' ] >>> spam . sort () >>> spam [ 'ants' , 'badgers' , 'cats' , 'dogs' , 'elephants' ] You can also pass True for the reverse keyword argument to have sort() sort the values in reverse order: >>> spam . sort ( reverse = True ) >>> spam [ 'elephants' , 'dogs' , 'cats' , 'badgers' , 'ants' ] If you need to sort the values in regular alphabetical order, pass str. lower for the key keyword argument in the sort() method call: >>> spam = [ 'a' , 'z' , 'A' , 'Z' ] >>> spam . sort ( key = str . lower ) >>> spam [ 'a' , 'A' , 'z' , 'Z' ] You can use the built-in function sorted to return a new list: >>> spam = [ 'ants' , 'cats' , 'dogs' , 'badgers' , 'elephants' ] >>> sorted ( spam ) [ 'ants' , 'badgers' , 'cats' , 'dogs' , 'elephants' ]","title":"Sorting the Values in a List with the sort() Method"},{"location":"Python/#tuple-data-type","text":">>> eggs = ( 'hello' , 42 , 0.5 ) >>> eggs [ 0 ] 'hello' >>> eggs [ 1 : 3 ] ( 42 , 0.5 ) >>> len ( eggs ) 3 The main way that tuples are different from lists is that tuples, like strings, are immutable (can't be changed).","title":"Tuple Data Type"},{"location":"Python/#converting-types-with-the-list-and-tuple-functions","text":">>> tuple ([ 'cat' , 'dog' , 5 ]) ( 'cat' , 'dog' , 5 ) >>> list (( 'cat' , 'dog' , 5 )) [ 'cat' , 'dog' , 5 ] >>> list ( 'hello' ) [ 'h' , 'e' , 'l' , 'l' , 'o' ]","title":"Converting Types with the list() and tuple() Functions"},{"location":"Python/#dictionaries-and-structuring-data","text":"From the Python 3 documentation About dictionaries Another useful data type built into Python is the dictionary (see Mapping Types \u2014 dict ). Dictionaries are sometimes found in other languages as \u201cassociative memories\u201d or \u201cassociative arrays\u201d. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys , which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can\u2019t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like append() and extend() . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: {} . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with del . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing list(d) on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use sorted(d) instead). To check whether a single key is in the dictionary, use the in keyword. Example Dictionary: myCat = { 'size' : 'fat' , 'color' : 'gray' , 'disposition' : 'loud' }","title":"Dictionaries and Structuring Data"},{"location":"Python/#the-keys-values-and-items-methods","text":"values(): >>> spam = { 'color' : 'red' , 'age' : 42 } >>> for v in spam . values (): >>> print ( v ) red 42 keys(): >>> for k in spam . keys (): >>> print ( k ) color age items(): >>> for i in spam . items (): >>> print ( i ) ( 'color' , 'red' ) ( 'age' , 42 ) Using the keys(), values(), and items() methods, a for loop can iterate over the keys, values, or key-value pairs in a dictionary, respectively. >>> spam = { 'color' : 'red' , 'age' : 42 } >>> >>> for k , v in spam . items (): >>> print ( 'Key: {} Value: {} ' . format ( k , str ( v ))) Key : age Value : 42 Key : color Value : red","title":"The keys(), values(), and items() Methods"},{"location":"Python/#checking-whether-a-key-or-value-exists-in-a-dictionary","text":">>> spam = { 'name' : 'Zophie' , 'age' : 7 } >>> 'name' in spam . keys () True >>> 'Zophie' in spam . values () True >>> # You can omit the call to keys() when checking for a key >>> 'color' in spam False >>> 'color' not in spam True","title":"Checking Whether a Key or Value Exists in a Dictionary"},{"location":"Python/#the-get-method","text":"Get has two parameters: key and default value if the key did not exist >>> picnic_items = { 'apples' : 5 , 'cups' : 2 } >>> 'I am bringing {} cups.' . format ( str ( picnic_items . get ( 'cups' , 0 ))) 'I am bringing 2 cups.' >>> 'I am bringing {} eggs.' . format ( str ( picnic_items . get ( 'eggs' , 0 ))) 'I am bringing 0 eggs.'","title":"The get() Method"},{"location":"Python/#the-setdefault-method","text":"Let's consider this code: spam = { 'name' : 'Pooka' , 'age' : 5 } if 'color' not in spam : spam [ 'color' ] = 'black' Using setdefault we could write the same code more succinctly: >>> spam = { 'name' : 'Pooka' , 'age' : 5 } >>> spam . setdefault ( 'color' , 'black' ) 'black' >>> spam { 'color' : 'black' , 'age' : 5 , 'name' : 'Pooka' } >>> spam . setdefault ( 'color' , 'white' ) 'black' >>> spam { 'color' : 'black' , 'age' : 5 , 'name' : 'Pooka' }","title":"The setdefault() Method"},{"location":"Python/#pretty-printing","text":">>> import pprint >>> >>> message = 'It was a bright cold day in April, and the clocks were striking >>> thirteen . ' >>> count = {} >>> >>> for character in message : >>> count . setdefault ( character , 0 ) >>> count [ character ] = count [ character ] + 1 >>> >>> pprint . pprint ( count ) { ' ' : 13 , ',' : 1 , '.' : 1 , 'A' : 1 , 'I' : 1 , 'a' : 4 , 'b' : 1 , 'c' : 3 , 'd' : 3 , 'e' : 5 , 'g' : 2 , 'h' : 3 , 'i' : 6 , 'k' : 2 , 'l' : 3 , 'n' : 4 , 'o' : 2 , 'p' : 1 , 'r' : 5 , 's' : 3 , 't' : 6 , 'w' : 2 , 'y' : 1 }","title":"Pretty Printing"},{"location":"Python/#merge-two-dictionaries","text":"# in Python 3.5+: >>> x = { 'a' : 1 , 'b' : 2 } >>> y = { 'b' : 3 , 'c' : 4 } >>> z = { ** x , ** y } >>> z { 'c' : 4 , 'a' : 1 , 'b' : 3 } # in Python 2.7 >>> z = dict ( x , ** y ) >>> z { 'c' : 4 , 'a' : 1 , 'b' : 3 }","title":"Merge two dictionaries"},{"location":"Python/#sets","text":"From the Python 3 documentation About Sets A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference.","title":"Sets"},{"location":"Python/#initializing-a-set","text":"There are two ways to create sets: using curly braces {} and the built-in function set() >>> s = { 1 , 2 , 3 } >>> s = set ([ 1 , 2 , 3 ]) When creating an empty set, be sure to not use the curly braces {} or you will get an empty dictionary instead. >>> s = {} >>> type ( s ) < class ' dict '>","title":"Initializing a set"},{"location":"Python/#sets-unordered-collections-of-unique-elements","text":"A set automatically remove all the duplicate values. >>> s = { 1 , 2 , 3 , 2 , 3 , 4 } >>> s { 1 , 2 , 3 , 4 } And as an unordered data type, they can't be indexed. >>> s = { 1 , 2 , 3 } >>> s [ 0 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'set' object does not support indexing >>>","title":"Sets: unordered collections of unique elements"},{"location":"Python/#set-add-and-update","text":"Using the add() method we can add a single element to the set. >>> s = { 1 , 2 , 3 } >>> s . add ( 4 ) >>> s { 1 , 2 , 3 , 4 } And with update() , multiple ones . >>> s = { 1 , 2 , 3 } >>> s . update ([ 2 , 3 , 4 , 5 , 6 ]) >>> s { 1 , 2 , 3 , 4 , 5 , 6 } # remember, sets automatically remove duplicates","title":"Set add() and update()"},{"location":"Python/#set-remove-and-discard","text":"Both methods will remove an element from the set, but remove() will raise a key error if the value doesn't exist. >>> s = { 1 , 2 , 3 } >>> s . remove ( 3 ) >>> s { 1 , 2 } >>> s . remove ( 3 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > KeyError : 3 discard() won't raise any errors. >>> s = { 1 , 2 , 3 } >>> s . discard ( 3 ) >>> s { 1 , 2 } >>> s . discard ( 3 ) >>>","title":"Set remove() and discard()"},{"location":"Python/#set-union","text":"union() or | will create a new set that contains all the elements from the sets provided. >>> s1 = { 1 , 2 , 3 } >>> s2 = { 3 , 4 , 5 } >>> s1 . union ( s2 ) # or 's1 | s2' { 1 , 2 , 3 , 4 , 5 }","title":"Set union()"},{"location":"Python/#set-intersection","text":"intersection or & will return a set containing only the elements that are common to all of them. >>> s1 = { 1 , 2 , 3 } >>> s2 = { 2 , 3 , 4 } >>> s3 = { 3 , 4 , 5 } >>> s1 . intersection ( s2 , s3 ) # or 's1 & s2 & s3' { 3 }","title":"Set intersection"},{"location":"Python/#set-difference","text":"difference or - will return only the elements that are unique to the first set (invoked set). >>> s1 = { 1 , 2 , 3 } >>> s2 = { 2 , 3 , 4 } >>> s1 . difference ( s2 ) # or 's1 - s2' { 1 } >>> s2 . difference ( s1 ) # or 's2 - s1' { 4 }","title":"Set difference"},{"location":"Python/#set-symetric_difference","text":"symetric_difference or ^ will return all the elements that are not common between them. >>> s1 = { 1 , 2 , 3 } >>> s2 = { 2 , 3 , 4 } >>> s1 . symmetric_difference ( s2 ) # or 's1 ^ s2' { 1 , 4 }","title":"Set symetric_difference"},{"location":"Python/#itertools-module","text":"The itertools module is a collection of tools intended to be fast and use memory efficiently when handling iterators (like lists or dictionaries ). From the official Python 3.x documentation : About itertools The module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an \u201citerator algebra\u201d making it possible to construct specialized tools succinctly and efficiently in pure Python. The itertools module comes in the standard library and must be imported. The operator module will also be used. This module is not necessary when using itertools, but needed for some of the examples below.","title":"itertools Module"},{"location":"Python/#accumulate","text":"Makes an iterator that returns the results of a function. itertools . accumulate ( iterable [, func ]) Example: >>> data = [ 1 , 2 , 3 , 4 , 5 ] >>> result = itertools . accumulate ( data , operator . mul ) >>> for each in result : >>> print ( each ) 1 2 6 24 120 The operator.mul takes two numbers and multiplies them: operator . mul ( 1 , 2 ) 2 operator . mul ( 2 , 3 ) 6 operator . mul ( 6 , 4 ) 24 operator . mul ( 24 , 5 ) 120 Passing a function is optional: >>> data = [ 5 , 2 , 6 , 4 , 5 , 9 , 1 ] >>> result = itertools . accumulate ( data ) >>> for each in result : >>> print ( each ) 5 7 13 17 22 31 32 If no function is designated the items will be summed: 5 5 + 2 = 7 7 + 6 = 13 13 + 4 = 17 17 + 5 = 22 22 + 9 = 31 31 + 1 = 32","title":"accumulate()"},{"location":"Python/#combinations","text":"Takes an iterable and a integer. This will create all the unique combination that have r members. itertools . combinations ( iterable , r ) Example: >>> shapes = [ 'circle' , 'triangle' , 'square' ,] >>> result = itertools . combinations ( shapes , 2 ) >>> for each in result : >>> print ( each ) ( 'circle' , 'triangle' ) ( 'circle' , 'square' ) ( 'triangle' , 'square' )","title":"combinations()"},{"location":"Python/#combinations_with_replacement","text":"Just like combinations(), but allows individual elements to be repeated more than once. itertools . combinations_with_replacement ( iterable , r ) Example: >>> shapes = [ 'circle' , 'triangle' , 'square' ] >>> result = itertools . combinations_with_replacement ( shapes , 2 ) >>> for each in result : >>> print ( each ) ( 'circle' , 'circle' ) ( 'circle' , 'triangle' ) ( 'circle' , 'square' ) ( 'triangle' , 'triangle' ) ( 'triangle' , 'square' ) ( 'square' , 'square' )","title":"combinations_with_replacement()"},{"location":"Python/#count","text":"Makes an iterator that returns evenly spaced values starting with number start. itertools . count ( start = 0 , step = 1 ) Example: >>> for i in itertools . count ( 10 , 3 ): >>> print ( i ) >>> if i > 20 : >>> break 10 13 16 19 22","title":"count()"},{"location":"Python/#cycle","text":"This function cycles through an iterator endlessly. itertools . cycle ( iterable ) Example: >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'violet' ] >>> for color in itertools . cycle ( colors ): >>> print ( color ) red orange yellow green blue violet red orange When reached the end of the iterable it start over again from the beginning.","title":"cycle()"},{"location":"Python/#chain","text":"Take a series of iterables and return them as one long iterable. itertools . chain ( * iterables ) Example: >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' ] >>> shapes = [ 'circle' , 'triangle' , 'square' , 'pentagon' ] >>> result = itertools . chain ( colors , shapes ) >>> for each in result : >>> print ( each ) red orange yellow green blue circle triangle square pentagon","title":"chain()"},{"location":"Python/#compress","text":"Filters one iterable with another. itertools . compress ( data , selectors ) Example: >>> shapes = [ 'circle' , 'triangle' , 'square' , 'pentagon' ] >>> selections = [ True , False , True , False ] >>> result = itertools . compress ( shapes , selections ) >>> for each in result : >>> print ( each ) circle square","title":"compress()"},{"location":"Python/#dropwhile","text":"Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. itertools . dropwhile ( predicate , iterable ) Example: >>> data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 1 ] >>> result = itertools . dropwhile ( lambda x : x < 5 , data ) >>> for each in result : >>> print ( each ) 5 6 7 8 9 10 1","title":"dropwhile()"},{"location":"Python/#filterfalse","text":"Makes an iterator that filters elements from iterable returning only those for which the predicate is False. itertools . filterfalse ( predicate , iterable ) Example: >>> data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 1 ] >>> result = itertools . filterfalse ( lambda x : x < 5 , data ) >>> for each in result : >>> print ( each ) 5 6 7 8 9 10","title":"filterfalse()"},{"location":"Python/#groupby","text":"Simply put, this function groups things together. itertools . groupby ( iterable , key = None ) Example: >>> robots = [{ 'name' : 'blaster' , 'faction' : 'autobot' }, { 'name' : 'galvatron' , 'faction' : 'decepticon' }, { 'name' : 'jazz' , 'faction' : 'autobot' }, { 'name' : 'metroplex' , 'faction' : 'autobot' }, { 'name' : 'megatron' , 'faction' : 'decepticon' }, { 'name' : 'starcream' , 'faction' : 'decepticon' }] >>> for key , group in itertools . groupby ( robots , key = lambda x : x [ 'faction' ]): >>> print ( key ) >>> print ( list ( group )) autobot [{ 'name' : 'blaster' , 'faction' : 'autobot' }] decepticon [{ 'name' : 'galvatron' , 'faction' : 'decepticon' }] autobot [{ 'name' : 'jazz' , 'faction' : 'autobot' }, { 'name' : 'metroplex' , 'faction' : 'autobot' }] decepticon [{ 'name' : 'megatron' , 'faction' : 'decepticon' }, { 'name' : 'starcream' , 'faction' : 'decept","title":"groupby()"},{"location":"Python/#islice","text":"This function is very much like slices. This allows you to cut out a piece of an iterable. itertools . islice ( iterable , start , stop [, step ]) Example: >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' ,] >>> few_colors = itertools . islice ( colors , 2 ) >>> for each in few_colors : >>> print ( each ) red orange","title":"islice()"},{"location":"Python/#permutations","text":"itertools . permutations ( iterable , r = None ) Example: >>> alpha_data = [ 'a' , 'b' , 'c' ] >>> result = itertools . permutations ( alpha_data ) >>> for each in result : >>> print ( each ) ( 'a' , 'b' , 'c' ) ( 'a' , 'c' , 'b' ) ( 'b' , 'a' , 'c' ) ( 'b' , 'c' , 'a' ) ( 'c' , 'a' , 'b' ) ( 'c' , 'b' , 'a' )","title":"permutations()"},{"location":"Python/#product","text":"Creates the cartesian products from a series of iterables. >>> num_data = [ 1 , 2 , 3 ] >>> alpha_data = [ 'a' , 'b' , 'c' ] >>> result = itertools . product ( num_data , alpha_data ) >>> for each in result : print ( each ) ( 1 , 'a' ) ( 1 , 'b' ) ( 1 , 'c' ) ( 2 , 'a' ) ( 2 , 'b' ) ( 2 , 'c' ) ( 3 , 'a' ) ( 3 , 'b' ) ( 3 , 'c' )","title":"product()"},{"location":"Python/#repeat","text":"This function will repeat an object over and over again. Unless, there is a times argument. itertools . repeat ( object [, times ]) Example: >>> for i in itertools . repeat ( \"spam\" , 3 ): print ( i ) spam spam spam","title":"repeat()"},{"location":"Python/#starmap","text":"Makes an iterator that computes the function using arguments obtained from the iterable. itertools . starmap ( function , iterable ) Example: >>> data = [( 2 , 6 ), ( 8 , 4 ), ( 7 , 3 )] >>> result = itertools . starmap ( operator . mul , data ) >>> for each in result : >>> print ( each ) 12 32 21","title":"starmap()"},{"location":"Python/#takewhile","text":"The opposite of dropwhile(). Makes an iterator and returns elements from the iterable as long as the predicate is true. itertools . takewhile ( predicate , iterable ) Example: >>> data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 1 ] >>> result = itertools . takewhile ( lambda x : x < 5 , data ) >>> for each in result : >>> print ( each ) 1 2 3 4","title":"takewhile()"},{"location":"Python/#tee","text":"Return n independent iterators from a single iterable. itertools . tee ( iterable , n = 2 ) Example: >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' ] >>> alpha_colors , beta_colors = itertools . tee ( colors ) >>> for each in alpha_colors : >>> print ( each ) red orange yellow green blue >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' ] >>> alpha_colors , beta_colors = itertools . tee ( colors ) >>> for each in beta_colors : >>> print ( each ) red orange yellow green blue","title":"tee()"},{"location":"Python/#zip_longest","text":"Makes an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. itertools . zip_longest ( * iterables , fillvalue = None ) Example: >>> colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' ,] >>> data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ,] >>> for each in itertools . zip_longest ( colors , data , fillvalue = None ): >>> print ( each ) ( 'red' , 1 ) ( 'orange' , 2 ) ( 'yellow' , 3 ) ( 'green' , 4 ) ( 'blue' , 5 ) ( None , 6 ) ( None , 7 ) ( None , 8 ) ( None , 9 ) ( None , 10 )","title":"zip_longest()"},{"location":"Python/#comprehensions","text":"","title":"Comprehensions"},{"location":"Python/#list-comprehension","text":">>> a = [ 1 , 3 , 5 , 7 , 9 , 11 ] >>> [ i - 1 for i in a ] [ 0 , 2 , 4 , 6 , 8 , 10 ]","title":"List comprehension"},{"location":"Python/#set-comprehension","text":">>> b = { \"abc\" , \"def\" } >>> { s . upper () for s in b } { \"ABC\" , \"DEF\" }","title":"Set comprehension"},{"location":"Python/#dict-comprehension","text":">>> c = { 'name' : 'Pooka' , 'age' : 5 } >>> { v : k for k , v in c . items ()} { 'Pooka' : 'name' , 5 : 'age' } A List comprehension can be generated from a dictionary: >>> c = { 'name' : 'Pooka' , 'first_name' : 'Oooka' } >>> [ \" {} : {} \" . format ( k . upper (), v . upper ()) for k , v in c . items ()] [ 'NAME:POOKA' , 'FIRST_NAME:OOOKA' ]","title":"Dict comprehension"},{"location":"Python/#manipulating-strings","text":"","title":"Manipulating Strings"},{"location":"Python/#escape-characters","text":"Escape character Prints as \\' Single quote \\\" Double quote \\t Tab \\n Newline (linebreak) \\\\ Backslash Example: >>> print ( \"Hello there! \\n How are you? \\n I \\' m doing fine.\" ) Hello there ! How are you ? I 'm doing fine.","title":"Escape Characters"},{"location":"Python/#raw-strings","text":"A raw string completely ignores all escape characters and prints any backslash that appears in the string. >>> print ( r 'That is Carol \\' s cat.' ) That is Carol \\ 's cat. Note: mostly used for regular expression definition (see re package)","title":"Raw Strings"},{"location":"Python/#multiline-strings-with-triple-quotes","text":">>> print ( '''Dear Alice, >>> >>> Eve's cat has been arrested for catnapping, cat burglary, and extortion. >>> >>> Sincerely, >>> Bob''' ) Dear Alice , Eve 's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely , Bob To keep a nicer flow in your code, you can use the dedent function from the textwrap standard package. >>> from textwrap import dedent >>> >>> def my_function (): >>> print ( ''' >>> Dear Alice, >>> >>> Eve's cat has been arrested for catnapping, cat burglary, and extortion. >>> >>> Sincerely, >>> Bob >>> ''' ) . strip () This generates the same string than before.","title":"Multiline Strings with Triple Quotes"},{"location":"Python/#indexing-and-slicing-strings","text":"H e l l o w o r l d ! 0 1 2 3 4 5 6 7 8 9 10 11 >>> spam = 'Hello world!' >>> spam [ 0 ] 'H' >>> spam [ 4 ] 'o' >>> spam [ - 1 ] '!' Slicing: >>> spam [ 0 : 5 ] 'Hello' >>> spam [: 5 ] 'Hello' >>> spam [ 6 :] 'world!' >>> spam [ 6 : - 1 ] 'world' >>> spam [: - 1 ] 'Hello world' >>> spam [:: - 1 ] '!dlrow olleH' >>> spam = 'Hello world!' >>> fizz = spam [ 0 : 5 ] >>> fizz 'Hello'","title":"Indexing and Slicing Strings"},{"location":"Python/#the-in-and-not-in-operators-with-strings","text":">>> 'Hello' in 'Hello World' True >>> 'Hello' in 'Hello' True >>> 'HELLO' in 'Hello World' False >>> '' in 'spam' True >>> 'cats' not in 'cats and dogs' False","title":"The in and not in Operators with Strings"},{"location":"Python/#the-in-and-not-in-operators-with-list","text":">>> a = [ 1 , 2 , 3 , 4 ] >>> 5 in a False >>> 2 in a True","title":"The in and not in Operators with list"},{"location":"Python/#the-upper-lower-isupper-and-islower-string-methods","text":"upper() and lower() : >>> spam = 'Hello world!' >>> spam = spam . upper () >>> spam 'HELLO WORLD!' >>> spam = spam . lower () >>> spam 'hello world!' isupper() and islower(): >>> spam = 'Hello world!' >>> spam . islower () False >>> spam . isupper () False >>> 'HELLO' . isupper () True >>> 'abc12345' . islower () True >>> '12345' . islower () False >>> '12345' . isupper () False","title":"The upper(), lower(), isupper(), and islower() String Methods"},{"location":"Python/#the-isx-string-methods","text":"isalpha() returns True if the string consists only of letters and is not blank. isalnum() returns True if the string consists only of letters and numbers and is not blank. isdecimal() returns True if the string consists only of numeric characters and is not blank. isspace() returns True if the string consists only of spaces, tabs, and new-lines and is not blank. istitle() returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters.","title":"The isX String Methods"},{"location":"Python/#the-startswith-and-endswith-string-methods","text":">>> 'Hello world!' . startswith ( 'Hello' ) True >>> 'Hello world!' . endswith ( 'world!' ) True >>> 'abc123' . startswith ( 'abcdef' ) False >>> 'abc123' . endswith ( '12' ) False >>> 'Hello world!' . startswith ( 'Hello world!' ) True >>> 'Hello world!' . endswith ( 'Hello world!' ) True","title":"The startswith() and endswith() String Methods"},{"location":"Python/#the-join-and-split-string-methods","text":"join(): >>> ', ' . join ([ 'cats' , 'rats' , 'bats' ]) 'cats, rats, bats' >>> ' ' . join ([ 'My' , 'name' , 'is' , 'Simon' ]) 'My name is Simon' >>> 'ABC' . join ([ 'My' , 'name' , 'is' , 'Simon' ]) 'MyABCnameABCisABCSimon' split(): >>> 'My name is Simon' . split () [ 'My' , 'name' , 'is' , 'Simon' ] >>> 'MyABCnameABCisABCSimon' . split ( 'ABC' ) [ 'My' , 'name' , 'is' , 'Simon' ] >>> 'My name is Simon' . split ( 'm' ) [ 'My na' , 'e is Si' , 'on' ]","title":"The join() and split() String Methods"},{"location":"Python/#justifying-text-with-rjust-ljust-and-center","text":"rjust() and ljust(): >>> 'Hello' . rjust ( 10 ) ' Hello' >>> 'Hello' . rjust ( 20 ) ' Hello' >>> 'Hello World' . rjust ( 20 ) ' Hello World' >>> 'Hello' . ljust ( 10 ) 'Hello ' An optional second argument to rjust() and ljust() will specify a fill character other than a space character. Enter the following into the interactive shell: >>> 'Hello' . rjust ( 20 , '*' ) '***************Hello' >>> 'Hello' . ljust ( 20 , '-' ) 'Hello---------------' center(): >>> 'Hello' . center ( 20 ) ' Hello ' >>> 'Hello' . center ( 20 , '=' ) '=======Hello========'","title":"Justifying Text with rjust(), ljust(), and center()"},{"location":"Python/#removing-whitespace-with-strip-rstrip-and-lstrip","text":">>> spam = ' Hello World ' >>> spam . strip () 'Hello World' >>> spam . lstrip () 'Hello World ' >>> spam . rstrip () ' Hello World' >>> spam = 'SpamSpamBaconSpamEggsSpamSpam' >>> spam . strip ( 'ampS' ) 'BaconSpamEggs'","title":"Removing Whitespace with strip(), rstrip(), and lstrip()"},{"location":"Python/#copying-and-pasting-strings-with-the-pyperclip-module-need-pip-install","text":">>> import pyperclip >>> pyperclip . copy ( 'Hello world!' ) >>> pyperclip . paste () 'Hello world!'","title":"Copying and Pasting Strings with the pyperclip Module (need pip install)"},{"location":"Python/#string-formatting","text":"","title":"String Formatting"},{"location":"Python/#operator","text":">>> name = 'Pete' >>> 'Hello %s ' % name \"Hello Pete\" We can use the %x format specifier to convert an int value to a string: >>> num = 5 >>> 'I have %x apples' % num \"I have 5 apples\" Note : For new code, using [[#String Formatting str format|str-format]] or [[#Formatted String Literals or f-strings Python 3 6|f-strings]] (Python 3.6+) is strongly recommended over the % operator.","title":"% operator"},{"location":"Python/#string-formatting-strformat","text":"Python 3 introduced a new way to do string formatting that was later back-ported to Python 2.7. This makes the syntax for string formatting more regular. >>> name = 'John' >>> age = 20 ' >>> \"Hello I'm {} , my age is {} \" . format ( name , age ) \"Hello I'm John, my age is 20\" >>> \"Hello I'm {0} , my age is {1} \" . format ( name , age ) \"Hello I'm John, my age is 20\" The official Python 3.x documentation recommend str.format over the % operator: The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). Using the newer formatted string literals or the str.format() interface helps avoid these errors. These alternatives also provide more powerful, flexible and extensible approaches to formatting text.","title":"String Formatting (str.format)"},{"location":"Python/#lazy-string-formatting","text":"You would only use %s string formatting on functions that can do lazy parameters evaluation, the most common being logging: Prefer: >>> name = \"alice\" >>> logging . debug ( \"User name: %s \" , name ) Over: >>> logging . debug ( \"User name: {} \" . format ( name )) Or: >>> logging . debug ( \"User name: \" + name )","title":"Lazy string formatting"},{"location":"Python/#formatted-string-literals-or-f-strings-python-36","text":">>> name = 'Elizabeth' >>> f 'Hello { name } !' 'Hello Elizabeth! It is even possible to do inline arithmetic with it: >>> a = 5 >>> b = 10 >>> f 'Five plus ten is { a + b } and not { 2 * ( a + b ) } .' 'Five plus ten is 15 and not 30.'","title":"Formatted String Literals or f-strings (Python 3.6+)"},{"location":"Python/#template-strings","text":"A simpler and less powerful mechanism, but it is recommended when handling format strings generated by users. Due to their reduced complexity template strings are a safer choice. >>> from string import Template >>> name = 'Elizabeth' >>> t = Template ( 'Hey $name!' ) >>> t . substitute ( name = name ) 'Hey Elizabeth!'","title":"Template Strings"},{"location":"Python/#regular-expressions","text":"Import the regex module with import re . Create a Regex object with the re.compile() function. (Remember to use a raw string.) Pass the string you want to search into the Regex object\u2019s search() method. This returns a Match object. Call the Match object\u2019s group() method to return a string of the actual matched text. All the regex functions in Python are in the re module: >>> import re","title":"Regular Expressions"},{"location":"Python/#matching-regex-objects","text":">>> phone_num_regex = re . compile ( r '\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d' ) >>> mo = phone_num_regex . search ( 'My number is 415-555-4242.' ) >>> print ( 'Phone number found: {} ' . format ( mo . group ())) Phone number found : 415 - 555 - 4242","title":"Matching Regex Objects"},{"location":"Python/#grouping-with-parentheses","text":">>> phone_num_regex = re . compile ( r '(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)' ) >>> mo = phone_num_regex . search ( 'My number is 415-555-4242.' ) >>> mo . group ( 1 ) '415' >>> mo . group ( 2 ) '555-4242' >>> mo . group ( 0 ) '415-555-4242' >>> mo . group () '415-555-4242' To retrieve all the groups at once: use the groups() method\u2014note the plural form for the name. >>> mo . groups () ( '415' , '555-4242' ) >>> area_code , main_number = mo . groups () >>> print ( area_code ) 415 >>> print ( main_number ) 555 - 4242","title":"Grouping with Parentheses"},{"location":"Python/#matching-multiple-groups-with-the-pipe","text":"The | character is called a pipe. You can use it anywhere you want to match one of many expressions. For example, the regular expression r'Batman|Tina Fey' will match either 'Batman' or 'Tina Fey'. >>> hero_regex = re . compile ( r 'Batman|Tina Fey' ) >>> mo1 = hero_regex . search ( 'Batman and Tina Fey.' ) >>> mo1 . group () 'Batman' >>> mo2 = hero_regex . search ( 'Tina Fey and Batman.' ) >>> mo2 . group () 'Tina Fey' You can also use the pipe to match one of several patterns as part of your regex: >>> bat_regex = re . compile ( r 'Bat(man|mobile|copter|bat)' ) >>> mo = bat_regex . search ( 'Batmobile lost a wheel' ) >>> mo . group () 'Batmobile' >>> mo . group ( 1 ) 'mobile'","title":"Matching Multiple Groups with the Pipe"},{"location":"Python/#optional-matching-with-the-question-mark","text":"The ? character flags the group that precedes it as an optional part of the pattern. >>> bat_regex = re . compile ( r 'Bat(wo)?man' ) >>> mo1 = bat_regex . search ( 'The Adventures of Batman' ) >>> mo1 . group () 'Batman' >>> mo2 = bat_regex . search ( 'The Adventures of Batwoman' ) >>> mo2 . group () 'Batwoman'","title":"Optional Matching with the Question Mark"},{"location":"Python/#matching-zero-or-more-with-the-star","text":"The * (called the star or asterisk) means \u201cmatch zero or more\u201d\u2014the group that precedes the star can occur any number of times in the text. >>> bat_regex = re . compile ( r 'Bat(wo)*man' ) >>> mo1 = bat_regex . search ( 'The Adventures of Batman' ) >>> mo1 . group () 'Batman' >>> mo2 = bat_regex . search ( 'The Adventures of Batwoman' ) >>> mo2 . group () 'Batwoman' >>> mo3 = bat_regex . search ( 'The Adventures of Batwowowowoman' ) >>> mo3 . group () 'Batwowowowoman'","title":"Matching Zero or More with the Star"},{"location":"Python/#matching-one-or-more-with-the-plus","text":"While * means \u201cmatch zero or more,\u201d the + (or plus) means \u201cmatch one or more\u201d. The group preceding a plus must appear at least once. It is not optional: >>> bat_regex = re . compile ( r 'Bat(wo)+man' ) >>> mo1 = bat_regex . search ( 'The Adventures of Batwoman' ) >>> mo1 . group () 'Batwoman' >>> mo2 = bat_regex . search ( 'The Adventures of Batwowowowoman' ) >>> mo2 . group () 'Batwowowowoman' >>> mo3 = bat_regex . search ( 'The Adventures of Batman' ) >>> mo3 is None True","title":"Matching One or More with the Plus"},{"location":"Python/#matching-specific-repetitions-with-curly-brackets","text":"If you have a group that you want to repeat a specific number of times, follow the group in your regex with a number in curly brackets. For example, the regex (Ha){3} will match the string 'HaHaHa', but it will not match 'HaHa', since the latter has only two repeats of the (Ha) group. Instead of one number, you can specify a range by writing a minimum, a comma, and a maximum in between the curly brackets. For example, the regex (Ha){3,5} will match 'HaHaHa', 'HaHaHaHa', and 'HaHaHaHaHa'. >>> ha_regex = re . compile ( r '(Ha) {3} ' ) >>> mo1 = ha_regex . search ( 'HaHaHa' ) >>> mo1 . group () 'HaHaHa' >>> mo2 = ha_regex . search ( 'Ha' ) >>> mo2 is None True","title":"Matching Specific Repetitions with Curly Brackets"},{"location":"Python/#greedy-and-nongreedy-matching","text":"Python\u2019s regular expressions are greedy by default, which means that in ambiguous situations they will match the longest string possible. The non-greedy version of the curly brackets, which matches the shortest string possible, has the closing curly bracket followed by a question mark. >>> greedy_ha_regex = re . compile ( r '(Ha){3,5}' ) >>> mo1 = greedy_ha_regex . search ( 'HaHaHaHaHa' ) >>> mo1 . group () 'HaHaHaHaHa' >>> nongreedy_ha_regex = re . compile ( r '(Ha){3,5}?' ) >>> mo2 = nongreedy_ha_regex . search ( 'HaHaHaHaHa' ) >>> mo2 . group () 'HaHaHa'","title":"Greedy and Nongreedy Matching"},{"location":"Python/#the-findall-method","text":"In addition to the search() method, Regex objects also have a findall() method. While search() will return a Match object of the first matched text in the searched string, the findall() method will return the strings of every match in the searched string. >>> phone_num_regex = re . compile ( r '\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d' ) # has no groups >>> phone_num_regex . findall ( 'Cell: 415-555-9999 Work: 212-555-0000' ) [ '415-555-9999' , '212-555-0000' ] To summarize what the findall() method returns, remember the following: When called on a regex with no groups, such as \\d-\\d\\d\\d-\\d\\d\\d\\d , the method findall() returns a list of ng matches, such as ['415-555-9999', '212-555-0000']. When called on a regex that has groups, such as ( \\d\\d\\d)-(d\\d)-(\\d\\d\\d\\d ), the method findall() returns a list of es of strings (one string for each group), such as [('415', '555', '9999'), ('212', '555', '0000')].","title":"The findall() Method"},{"location":"Python/#making-your-own-character-classes","text":"There are times when you want to match a set of characters but the shorthand character classes ( \\d, \\w, \\s, and so on) are too broad. You can define your own character class using square brackets. For example, the character class [aeiouAEIOU] will match any vowel, both lowercase and uppercase. >>> vowel_regex = re . compile ( r '[aeiouAEIOU]' ) >>> vowel_regex . findall ( 'Robocop eats baby food. BABY FOOD.' ) [ 'o' , 'o' , 'o' , 'e' , 'a' , 'a' , 'o' , 'o' , 'A' , 'O' , 'O' ] You can also include ranges of letters or numbers by using a hyphen. For example, the character class [a-zA-Z0-9] will match all lowercase letters, uppercase letters, and numbers. By placing a caret character (^) just after the character class\u2019s opening bracket, you can make a negative character class. A negative character class will match all the characters that are not in the character class. For example, enter the following into the interactive shell: >>> consonant_regex = re . compile ( r '[^aeiouAEIOU]' ) >>> consonant_regex . findall ( 'Robocop eats baby food. BABY FOOD.' ) [ 'R' , 'b' , 'c' , 'p' , ' ' , 't' , 's' , ' ' , 'b' , 'b' , 'y' , ' ' , 'f' , 'd' , '.' , ' ', ' B ', ' B ', ' Y ', ' ', ' F ', ' D ', ' . ']","title":"Making Your Own Character Classes"},{"location":"Python/#the-caret-and-dollar-sign-characters","text":"You can also use the caret symbol (^) at the start of a regex to indicate that a match must occur at the beginning of the searched text. Likewise, you can put a dollar sign ( \\$ ) at the end of the regex to indicate the string must end with this regex pattern. And you can use the ^ and \\$ together to indicate that the entire string must match the regex\u2014that is, it\u2019s not enough for a match to be made on some subset of the string. The r'^Hello' regular expression string matches strings that begin with 'Hello': >>> begins_with_hello = re . compile ( r '^Hello' ) >>> begins_with_hello . search ( 'Hello world!' ) < _sre . SRE_Match object ; span = ( 0 , 5 ), match = 'Hello' > >>> begins_with_hello . search ( 'He said hello.' ) is None True The r'\\d\\$' regular expression string matches strings that end with a numeric character from 0 to 9: >>> whole_string_is_num = re . compile ( r '^\\d+$' ) >>> whole_string_is_num . search ( '1234567890' ) < _sre . SRE_Match object ; span = ( 0 , 10 ), match = '1234567890' > >>> whole_string_is_num . search ( '12345xyz67890' ) is None True >>> whole_string_is_num . search ( '12 34567890' ) is None True","title":"The Caret and Dollar Sign Characters"},{"location":"Python/#the-wildcard-character","text":"The . (or dot) character in a regular expression is called a wildcard and will match any character except for a newline: >>> at_regex = re . compile ( r '.at' ) >>> at_regex . findall ( 'The cat in the hat sat on the flat mat.' ) [ 'cat' , 'hat' , 'sat' , 'lat' , 'mat' ]","title":"The Wildcard Character"},{"location":"Python/#matching-everything-with-dot-star","text":">>> name_regex = re . compile ( r 'First Name: (.*) Last Name: (.*)' ) >>> mo = name_regex . search ( 'First Name: Al Last Name: Sweigart' ) >>> mo . group ( 1 ) 'Al' >>> mo . group ( 2 ) 'Sweigart' The dot-star uses greedy mode: It will always try to match as much text as possible. To match any and all text in a nongreedy fashion, use the dot, star, and question mark (.*?). The question mark tells Python to match in a nongreedy way: >>> nongreedy_regex = re . compile ( r '<.*?>' ) >>> mo = nongreedy_regex . search ( '<To serve man> for dinner.>' ) >>> mo . group () '<To serve man>' >>> greedy_regex = re . compile ( r '<.*>' ) >>> mo = greedy_regex . search ( '<To serve man> for dinner.>' ) >>> mo . group () '<To serve man> for dinner.>'","title":"Matching Everything with Dot-Star"},{"location":"Python/#matching-newlines-with-the-dot-character","text":"The dot-star will match everything except a newline. By passing re.DOTALL as the second argument to re.compile(), you can make the dot character match all characters, including the newline character: >>> no_newline_regex = re . compile ( '.*' ) >>> no_newline_regex . search ( 'Serve the public trust. \\n Protect the innocent. \\n Uphold the law.' ) . group () 'Serve the public trust.' >>> newline_regex = re . compile ( '.*' , re . DOTALL ) >>> newline_regex . search ( 'Serve the public trust. \\n Protect the innocent. \\n Uphold the law.' ) . group () 'Serve the public trust. \\n Protect the innocent. \\n Uphold the law.'","title":"Matching Newlines with the Dot Character"},{"location":"Python/#review-of-regex-symbols","text":"Symbol Matches ? zero or one of the preceding group. * zero or more of the preceding group. + one or more of the preceding group. {n} exactly n of the preceding group. {n,} n or more of the preceding group. {,m} 0 to m if the preceding group. {n,m} at least n and at most m of the preceding p. {n,m}? or *? or +? performs a nongreedy match of the preceding p. ^spam means the string must begin with spam. spam$ means the string must end with spam. . any character, except newline characters. \\d , \\w , and \\s a digit, word or space character, respectively. \\D , \\W , and \\S anything except a digit, word or space, respectively. [abc] any character between the brackets (such as a, b). [^abc] any character that isn't between the brackets.","title":"Review of Regex Symbols"},{"location":"Python/#case-insensitive-matching","text":"To make your regex case-insensitive, you can pass re.IGNORECASE or re.I as a second argument to re.compile(): >>> robocop = re . compile ( r 'robocop' , re . I ) >>> robocop . search ( 'Robocop is part man, part machine, all cop.' ) . group () 'Robocop' >>> robocop . search ( 'ROBOCOP protects the innocent.' ) . group () 'ROBOCOP' >>> robocop . search ( 'Al, why does your programming book talk about robocop so much?' ) . group () 'robocop'","title":"Case-Insensitive Matching"},{"location":"Python/#substituting-strings-with-the-sub-method","text":"The sub() method for Regex objects is passed two arguments: The first argument is a string to replace any matches. The second is the string for the regular expression. The sub() method returns a string with the substitutions applied: >>> names_regex = re . compile ( r 'Agent \\w+' ) >>> names_regex . sub ( 'CENSORED' , 'Agent Alice gave the secret documents to Agent Bob.' ) 'CENSORED gave the secret documents to CENSORED.' Another example: >>> agent_names_regex = re . compile ( r 'Agent (\\w)\\w*' ) >>> agent_names_regex . sub ( r '\\1****' , 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.' ) A **** told C **** that E **** knew B **** was a double agent . '","title":"Substituting Strings with the sub() Method"},{"location":"Python/#managing-complex-regexes","text":"To tell the re.compile() function to ignore whitespace and comments inside the regular expression string, \u201cverbose mode\u201d can be enabled by passing the variable re.VERBOSE as the second argument to re.compile(). Now instead of a hard-to-read regular expression like this: phone_regex = re . compile ( r '((\\d {3} |\\(\\d {3} \\))?(\\s|-|\\.)?\\d {3} (\\s|-|\\.)\\d {4} (\\s*(ext|x|ext.)\\s*\\d{2,5})?)' ) you can spread the regular expression over multiple lines with comments like this: phone_regex = re . compile ( r '''( (\\d {3} |\\(\\d {3} \\))? # area code (\\s|-|\\.)? # separator \\d {3} # first 3 digits (\\s|-|\\.) # separator \\d {4} # last 4 digits (\\s*(ext|x|ext.)\\s*\\d{2,5})? # extension )''' , re . VERBOSE )","title":"Managing Complex Regexes"},{"location":"Python/#handling-file-and-directory-paths","text":"There are two main modules in Python that deals with path manipulation. One is the os.path module and the other is the pathlib module. The pathlib module was added in Python 3.4, offering an object-oriented way to handle file system paths.","title":"Handling File and Directory Paths"},{"location":"Python/#backslash-on-windows-and-forward-slash-on-os-x-and-linux","text":"On Windows, paths are written using backslashes ( \\ ) as the separator between folder names. On Unix based operating system such as macOS, Linux, and BSDs, the forward slash ( / ) is used as the path separator. Joining paths can be a headache if your code needs to work on different platforms. Fortunately, Python provides easy ways to handle this. We will showcase how to deal with this with both os.path.join and pathlib.Path.joinpath Using os.path.join on Windows: >>> import os >>> os . path . join ( 'usr' , 'bin' , 'spam' ) 'usr \\\\ bin \\\\ spam' And using pathlib on *nix: >>> from pathlib import Path >>> print ( Path ( 'usr' ) . joinpath ( 'bin' ) . joinpath ( 'spam' )) usr / bin / spam pathlib also provides a shortcut to joinpath using the / operator: >>> from pathlib import Path >>> print ( Path ( 'usr' ) / 'bin' / 'spam' ) usr / bin / spam Notice the path separator is different between Windows and Unix based operating system, that's why you want to use one of the above methods instead of adding strings together to join paths together. Joining paths is helpful if you need to create different file paths under the same directory. Using os.path.join on Windows: >>> my_files = [ 'accounts.txt' , 'details.csv' , 'invite.docx' ] >>> for filename in my_files : >>> print ( os . path . join ( 'C: \\\\ Users \\\\ asweigart' , filename )) C : \\ Users \\ user \\ accounts . txt C : \\ Users \\ user \\ details . csv C : \\ Users \\ user \\ invite . docx Using pathlib on *nix: >>> my_files = [ 'accounts.txt' , 'details.csv' , 'invite.docx' ] >>> home = Path . home () >>> for filename in my_files : >>> print ( home / filename ) / home / user / accounts . txt / home / user / details . csv / home / user / invite . docx","title":"Backslash on Windows and Forward Slash on OS X and Linux"},{"location":"Python/#the-current-working-directory","text":"Using os on Windows: >>> import os >>> os . getcwd () 'C: \\\\ Python34' >>> os . chdir ( 'C: \\\\ Windows \\\\ System32' ) >>> os . getcwd () 'C: \\\\ Windows \\\\ System32' Using pathlib on *nix: >>> from pathlib import Path >>> from os import chdir >>> print ( Path . cwd ()) / home / user >>> chdir ( '/usr/lib/python3.6' ) >>> print ( Path . cwd ()) / usr / lib / python3 .6","title":"The Current Working Directory"},{"location":"Python/#creating-new-folders","text":"Using os on Windows: >>> import os >>> os . makedirs ( 'C: \\\\ delicious \\\\ walnut \\\\ waffles' ) Using pathlib on *nix: >>> from pathlib import Path >>> cwd = Path . cwd () >>> ( cwd / 'delicious' / 'walnut' / 'waffles' ) . mkdir () Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/lib/python3.6/pathlib.py\" , line 1226 , in mkdir self . _accessor . mkdir ( self , mode ) File \"/usr/lib/python3.6/pathlib.py\" , line 387 , in wrapped return strfunc ( str ( pathobj ), * args ) FileNotFoundError : [ Errno 2 ] No such file or directory : '/home/user/delicious/walnut/waffles' Oh no, we got a nasty error! The reason is that the 'delicious' directory does not exist, so we cannot make the 'walnut' and the 'waffles' directories under it. To fix this, do: >>> from pathlib import Path >>> cwd = Path . cwd () >>> ( cwd / 'delicious' / 'walnut' / 'waffles' ) . mkdir ( parents = True ) And all is good :)","title":"Creating New Folders"},{"location":"Python/#absolute-vs-relative-paths","text":"There are two ways to specify a file path. An absolute path, which always begins with the root folder A relative path, which is relative to the program\u2019s current working directory There are also the dot (.) and dot-dot (..) folders. These are not real folders but special names that can be used in a path. A single period (\u201cdot\u201d) for a folder name is shorthand for \u201cthis directory.\u201d Two periods (\u201cdot-dot\u201d) means \u201cthe parent folder.\u201d","title":"Absolute vs. Relative Paths"},{"location":"Python/#handling-absolute-and-relative-paths","text":"To see if a path is an absolute path: Using os.path on *nix: >>> import os >>> os . path . isabs ( '/' ) True >>> os . path . isabs ( '..' ) False Using pathlib on *nix: >>> from pathlib import Path >>> Path ( '/' ) . is_absolute () True >>> Path ( '..' ) . is_absolute () False You can extract an absolute path with both os.path and pathlib Using os.path on *nix: >>> import os >>> os . getcwd () '/home/user' >>> os . path . abspath ( '..' ) '/home' Using pathlib on *nix: from pathlib import Path print ( Path . cwd ()) / home / user print ( Path ( '..' ) . resolve ()) / home You can get a relative path from a starting path to another path. Using os.path on *nix: >>> import os >>> os . path . relpath ( '/etc/passwd' , '/' ) 'etc/passwd' Using pathlib on *nix: >>> from pathlib import Path >>> print ( Path ( '/etc/passwd' ) . relative_to ( '/' )) etc / passwd","title":"Handling Absolute and Relative Paths"},{"location":"Python/#checking-path-validity","text":"Checking if a file/directory exists: Using os.path on *nix: import os >>> os . path . exists ( '.' ) True >>> os . path . exists ( 'setup.py' ) True >>> os . path . exists ( '/etc' ) True >>> os . path . exists ( 'nonexistentfile' ) False Using pathlib on *nix: from pathlib import Path >>> Path ( '.' ) . exists () True >>> Path ( 'setup.py' ) . exists () True >>> Path ( '/etc' ) . exists () True >>> Path ( 'nonexistentfile' ) . exists () False Checking if a path is a file: Using os.path on *nix: >>> import os >>> os . path . isfile ( 'setup.py' ) True >>> os . path . isfile ( '/home' ) False >>> os . path . isfile ( 'nonexistentfile' ) False Using pathlib on *nix: >>> from pathlib import Path >>> Path ( 'setup.py' ) . is_file () True >>> Path ( '/home' ) . is_file () False >>> Path ( 'nonexistentfile' ) . is_file () False Checking if a path is a directory: Using os.path on *nix: >>> import os >>> os . path . isdir ( '/' ) True >>> os . path . isdir ( 'setup.py' ) False >>> os . path . isdir ( '/spam' ) False Using pathlib on *nix: >>> from pathlib import Path >>> Path ( '/' ) . is_dir () True >>> Path ( 'setup.py' ) . is_dir () False >>> Path ( '/spam' ) . is_dir () False","title":"Checking Path Validity"},{"location":"Python/#finding-file-sizes-and-folder-contents","text":"Getting a file's size in bytes: Using os.path on Windows: >>> import os >>> os . path . getsize ( 'C: \\\\ Windows \\\\ System32 \\\\ calc.exe' ) 776192 Using pathlib on *nix: >>> from pathlib import Path >>> stat = Path ( '/bin/python3.6' ) . stat () >>> print ( stat ) # stat contains some other information about the file as well os . stat_result ( st_mode = 33261 , st_ino = 141087 , st_dev = 2051 , st_nlink = 2 , st_uid = 0 , -- snip -- st_gid = 0 , st_size = 10024 , st_atime = 1517725562 , st_mtime = 1515119809 , st_ctime = 1517261276 ) >>> print ( stat . st_size ) # size in bytes 10024 Listing directory contents using os.listdir on Windows: >>> import os >>> os . listdir ( 'C: \\\\ Windows \\\\ System32' ) [ '0409' , '12520437.cpx' , '12520850.cpx' , '5U877.ax' , 'aaclient.dll' , -- snip -- 'xwtpdui.dll' , 'xwtpw32.dll' , 'zh-CN' , 'zh-HK' , 'zh-TW' , 'zipfldr.dll' ] Listing directory contents using pathlib on *nix: >>> from pathlib import Path >>> for f in Path ( '/usr/bin' ) . iterdir (): >>> print ( f ) ... / usr / bin / tiff2rgba / usr / bin / iconv / usr / bin / ldd / usr / bin / cache_restore / usr / bin / udiskie / usr / bin / unix2dos / usr / bin / t1reencode / usr / bin / epstopdf / usr / bin / idle3 ... To find the total size of all the files in this directory: WARNING : Directories themselves also have a size! So you might want to check for whether a path is a file or directory using the methods in the methods discussed in the above section! Using os.path.getsize() and os.listdir() together on Windows: >>> import os >>> total_size = 0 >>> for filename in os . listdir ( 'C: \\\\ Windows \\\\ System32' ): total_size = total_size + os . path . getsize ( os . path . join ( 'C: \\\\ Windows \\\\ System32' , filename )) >>> print ( total_size ) 1117846456 Using pathlib on *nix: >>> from pathlib import Path >>> total_size = 0 >>> for sub_path in Path ( '/usr/bin' ) . iterdir (): ... total_size += sub_path . stat () . st_size >>> >>> print ( total_size ) 1903178911","title":"Finding File Sizes and Folder Contents"},{"location":"Python/#copying-files-and-folders","text":"The shutil module provides functions for copying files, as well as entire folders. >>> import shutil , os >>> os . chdir ( 'C: \\\\ ' ) >>> shutil . copy ( 'C: \\\\ spam.txt' , 'C: \\\\ delicious' ) 'C: \\\\ delicious \\\\ spam.txt' >>> shutil . copy ( 'eggs.txt' , 'C: \\\\ delicious \\\\ eggs2.txt' ) 'C: \\\\ delicious \\\\ eggs2.txt' While shutil.copy() will copy a single file, shutil.copytree() will copy an entire folder and every folder and file contained in it: >>> import shutil , os >>> os . chdir ( 'C: \\\\ ' ) >>> shutil . copytree ( 'C: \\\\ bacon' , 'C: \\\\ bacon_backup' ) 'C: \\\\ bacon_backup'","title":"Copying Files and Folders"},{"location":"Python/#moving-and-renaming-files-and-folders","text":">>> import shutil >>> shutil . move ( 'C: \\\\ bacon.txt' , 'C: \\\\ eggs' ) 'C: \\\\ eggs \\\\ bacon.txt' The destination path can also specify a filename. In the following example, the source file is moved and renamed: >>> shutil . move ( 'C: \\\\ bacon.txt' , 'C: \\\\ eggs \\\\ new_bacon.txt' ) 'C: \\\\ eggs \\\\ new_bacon.txt' If there is no eggs folder, then move() will rename bacon.txt to a file named eggs. >>> shutil . move ( 'C: \\\\ bacon.txt' , 'C: \\\\ eggs' ) 'C: \\\\ eggs'","title":"Moving and Renaming Files and Folders"},{"location":"Python/#permanently-deleting-files-and-folders","text":"Calling os.unlink(path) or Path.unlink() will delete the file at path. Calling os.rmdir(path) or Path.rmdir() will delete the folder at path. This folder must be empty of any files or folders. Calling shutil.rmtree(path) will remove the folder at path, and all files and folders it contains will also be deleted.","title":"Permanently Deleting Files and Folders"},{"location":"Python/#safe-deletes-with-the-send2trash-module","text":"You can install this module by running pip install send2trash from a Terminal window. >>> import send2trash >>> with open ( 'bacon.txt' , 'a' ) as bacon_file : # creates the file ... bacon_file . write ( 'Bacon is not a vegetable.' ) 25 >>> send2trash . send2trash ( 'bacon.txt' )","title":"Safe Deletes with the send2trash Module"},{"location":"Python/#walking-a-directory-tree","text":">>> import os >>> >>> for folder_name , subfolders , filenames in os . walk ( 'C: \\\\ delicious' ): >>> print ( 'The current folder is {} ' . format ( folder_name )) >>> >>> for subfolder in subfolders : >>> print ( 'SUBFOLDER OF {} : {} ' . format ( folder_name , subfolder )) >>> for filename in filenames : >>> print ( 'FILE INSIDE {} : {} ' . format ( folder_name , filename )) >>> >>> print ( '' ) The current folder is C : \\ delicious SUBFOLDER OF C : \\ delicious : cats SUBFOLDER OF C : \\ delicious : walnut FILE INSIDE C : \\ delicious : spam . txt The current folder is C : \\ delicious \\ cats FILE INSIDE C : \\ delicious \\ cats : catnames . txt FILE INSIDE C : \\ delicious \\ cats : zophie . jpg The current folder is C : \\ delicious \\ walnut SUBFOLDER OF C : \\ delicious \\ walnut : waffles The current folder is C : \\ delicious \\ walnut \\ waffles FILE INSIDE C : \\ delicious \\ walnut \\ waffles : butter . txt pathlib provides a lot more functionality than the ones listed above, like getting file name, getting file extension, reading/writing a file without manually opening it, etc. Check out the official documentation if you want to know more!","title":"Walking a Directory Tree"},{"location":"Python/#reading-and-writing-files","text":"","title":"Reading and Writing Files"},{"location":"Python/#the-file-readingwriting-process","text":"To read/write to a file in Python, you will want to use the with statement, which will close the file for you after you are done.","title":"The File Reading/Writing Process"},{"location":"Python/#opening-and-reading-files-with-the-open-function","text":">>> with open ( 'C: \\\\ Users \\\\ your_home_folder \\\\ hello.txt' ) as hello_file : ... hello_content = hello_file . read () >>> hello_content 'Hello World!' >>> # Alternatively, you can use the *readlines()* method to get a list of string values from the file, one string for each line of text: >>> with open ( 'sonnet29.txt' ) as sonnet_file : ... sonnet_file . readlines () [ When , in disgrace with fortune and men 's eyes, \\n ' , ' I all alone beweep my outcast state , \\ n ', And trouble deaf heaven with my bootless cries, \\n ' , And look upon myself and curse my fate , '] >>> # You can also iterate through the file line by line: >>> with open ( 'sonnet29.txt' ) as sonnet_file : ... for line in sonnet_file : # note the new line character will be included in the line ... print ( line , end = '' ) When , in disgrace with fortune and men 's eyes, I all alone beweep my outcast state , And trouble deaf heaven with my bootless cries , And look upon myself and curse my fate ,","title":"Opening and reading files with the open() function"},{"location":"Python/#writing-to-files","text":">>> with open ( 'bacon.txt' , 'w' ) as bacon_file : ... bacon_file . write ( 'Hello world! \\n ' ) 13 >>> with open ( 'bacon.txt' , 'a' ) as bacon_file : ... bacon_file . write ( 'Bacon is not a vegetable.' ) 25 >>> with open ( 'bacon.txt' ) as bacon_file : ... content = bacon_file . read () >>> print ( content ) Hello world ! Bacon is not a vegetable .","title":"Writing to Files"},{"location":"Python/#saving-variables-with-the-shelve-module","text":"To save variables: >>> import shelve >>> cats = [ 'Zophie' , 'Pooka' , 'Simon' ] >>> with shelve . open ( 'mydata' ) as shelf_file : ... shelf_file [ 'cats' ] = cats To open and read variables: >>> with shelve . open ( 'mydata' ) as shelf_file : ... print ( type ( shelf_file )) ... print ( shelf_file [ 'cats' ]) < class ' shelve . DbfilenameShelf '> [ 'Zophie' , 'Pooka' , 'Simon' ] Just like dictionaries, shelf values have keys() and values() methods that will return list-like values of the keys and values in the shelf. Since these methods return list-like values instead of true lists, you should pass them to the list() function to get them in list form. >>> with shelve . open ( 'mydata' ) as shelf_file : ... print ( list ( shelf_file . keys ())) ... print ( list ( shelf_file . values ())) [ 'cats' ] [[ 'Zophie' , 'Pooka' , 'Simon' ]]","title":"Saving Variables with the shelve Module"},{"location":"Python/#saving-variables-with-the-pprintpformat-function","text":">>> import pprint >>> cats = [{ 'name' : 'Zophie' , 'desc' : 'chubby' }, { 'name' : 'Pooka' , 'desc' : 'fluffy' }] >>> pprint . pformat ( cats ) \"[{'desc': 'chubby', 'name': 'Zophie'}, {'desc': 'fluffy', 'name': 'Pooka'}]\" >>> with open ( 'myCats.py' , 'w' ) as file_obj : ... file_obj . write ( 'cats = {} \\n ' . format ( pprint . pformat ( cats ))) 83","title":"Saving Variables with the pprint.pformat() Function"},{"location":"Python/#reading-zip-files","text":">>> import zipfile , os >>> os . chdir ( 'C: \\\\ ' ) # move to the folder with example.zip >>> with zipfile . ZipFile ( 'example.zip' ) as example_zip : ... print ( example_zip . namelist ()) ... spam_info = example_zip . getinfo ( 'spam.txt' ) ... print ( spam_info . file_size ) ... print ( spam_info . compress_size ) ... print ( 'Compressed file is %s x smaller!' % ( round ( spam_info . file_size / spam_info . compress_size , 2 ))) [ 'spam.txt' , 'cats/' , 'cats/catnames.txt' , 'cats/zophie.jpg' ] 13908 3828 'Compressed file is 3.63x smaller!'","title":"Reading ZIP Files"},{"location":"Python/#extracting-from-zip-files","text":"The extractall() method for ZipFile objects extracts all the files and folders from a ZIP file into the current working directory. >>> import zipfile , os >>> os . chdir ( 'C: \\\\ ' ) # move to the folder with example.zip >>> with zipfile . ZipFile ( 'example.zip' ) as example_zip : ... example_zip . extractall () The extract() method for ZipFile objects will extract a single file from the ZIP file. Continue the interactive shell example: >>> with zipfile . ZipFile ( 'example.zip' ) as example_zip : ... print ( example_zip . extract ( 'spam.txt' )) ... print ( example_zip . extract ( 'spam.txt' , 'C: \\\\ some \\\\ new \\\\ folders' )) 'C: \\\\ spam.txt' 'C: \\\\ some \\\\ new \\\\ folders \\\\ spam.txt'","title":"Extracting from ZIP Files"},{"location":"Python/#creating-and-adding-to-zip-files","text":">>> import zipfile >>> with zipfile . ZipFile ( 'new.zip' , 'w' ) as new_zip : ... new_zip . write ( 'spam.txt' , compress_type = zipfile . ZIP_DEFLATED ) This code will create a new ZIP file named new.zip that has the compressed contents of spam.txt.","title":"Creating and Adding to ZIP Files"},{"location":"Python/#json-yaml-and-configuration-files","text":"","title":"JSON, YAML and configuration files"},{"location":"Python/#json","text":"Open a JSON file with: import json with open ( \"filename.json\" , \"r\" ) as f : content = json . loads ( f . read ()) Write a JSON file with: import json content = { \"name\" : \"Joe\" , \"age\" : 20 } with open ( \"filename.json\" , \"w\" ) as f : f . write ( json . dumps ( content , indent = 2 ))","title":"JSON"},{"location":"Python/#yaml","text":"Compared to JSON, YAML allows for much better human maintainability and gives you the option to add comments. It is a convenient choice for configuration files where humans will have to edit it. There are two main libraries allowing to access to YAML files: PyYaml Ruamel.yaml Install them using pip install in your [[#Virtual Environment|virtual environment]] The first one it easier to use but the second one, Ruamel, implements much better the YAML specification, and allow for example to modify a YAML content without altering comments. Open a YAML file with: from ruamel.yaml import YAML with open ( \"filename.yaml\" ) as f : yaml = YAML () yaml . load ( f )","title":"YAML"},{"location":"Python/#anyconfig","text":"Anyconfig is a very handy package allowing to abstract completely the underlying configuration file format. It allows to load a Python dictionary from JSON, YAML, TOML, and so on. Install it with: pip install anyconfig Usage: import anyconfig conf1 = anyconfig . load ( \"/path/to/foo/conf.d/a.yml\" )","title":"Anyconfig"},{"location":"Python/#debugging","text":"","title":"Debugging"},{"location":"Python/#raising-exceptions","text":"Exceptions are raised with a raise statement. In code, a raise statement consists of the following: The raise keyword A call to the Exception() function A string with a helpful error message passed to the Exception() function >>> raise Exception ( 'This is the error message.' ) Traceback ( most recent call last ): File \"<pyshell#191>\" , line 1 , in < module > raise Exception ( 'This is the error message.' ) Exception : This is the error message . Often it\u2019s the code that calls the function, not the function itself, that knows how to handle an exception. So you will commonly see a raise statement inside a function and the try and except statements in the code calling the function. def box_print ( symbol , width , height ): if len ( symbol ) != 1 : raise Exception ( 'Symbol must be a single character string.' ) if width <= 2 : raise Exception ( 'Width must be greater than 2.' ) if height <= 2 : raise Exception ( 'Height must be greater than 2.' ) print ( symbol * width ) for i in range ( height - 2 ): print ( symbol + ( ' ' * ( width - 2 )) + symbol ) print ( symbol * width ) for sym , w , h in (( '*' , 4 , 4 ), ( 'O' , 20 , 5 ), ( 'x' , 1 , 3 ), ( 'ZZ' , 3 , 3 )): try : box_print ( sym , w , h ) except Exception as err : print ( 'An exception happened: ' + str ( err ))","title":"Raising Exceptions"},{"location":"Python/#getting-the-traceback-as-a-string","text":"The traceback is displayed by Python whenever a raised exception goes unhandled. But can also obtain it as a string by calling traceback.format_exc(). This function is useful if you want the information from an exception\u2019s traceback but also want an except statement to gracefully handle the exception. You will need to import Python\u2019s traceback module before calling this function. >>> import traceback >>> try : >>> raise Exception ( 'This is the error message.' ) >>> except : >>> with open ( 'errorInfo.txt' , 'w' ) as error_file : >>> error_file . write ( traceback . format_exc ()) >>> print ( 'The traceback info was written to errorInfo.txt.' ) 116 The traceback info was written to errorInfo . txt . The 116 is the return value from the write() method, since 116 characters were written to the file. The traceback text was written to errorInfo.txt. Traceback ( most recent call last ): File \"<pyshell#28>\" , line 2 , in < module > Exception : This is the error message .","title":"Getting the Traceback as a String"},{"location":"Python/#assertions","text":"An assertion is a sanity check to make sure your code isn\u2019t doing something obviously wrong. These sanity checks are performed by assert statements. If the sanity check fails, then an AssertionError exception is raised. In code, an assert statement consists of the following: The assert keyword A condition (that is, an expression that evaluates to True or False) A comma A string to display when the condition is False >>> pod_bay_door_status = 'open' >>> assert pod_bay_door_status == 'open' , 'The pod bay doors need to be \"open\".' >>> pod_bay_door_status = 'I \\' m sorry, Dave. I \\' m afraid I can \\' t do that.' >>> assert pod_bay_door_status == 'open' , 'The pod bay doors need to be \"open\".' Traceback ( most recent call last ): File \"<pyshell#10>\" , line 1 , in < module > assert pod_bay_door_status == 'open' , 'The pod bay doors need to be \"open\".' AssertionError : The pod bay doors need to be \"open\" . In plain English, an assert statement says, \u201cI assert that this condition holds true, and if not, there is a bug somewhere in the program.\u201d Unlike exceptions, your code should not handle assert statements with try and except; if an assert fails, your program should crash. By failing fast like this, you shorten the time between the original cause of the bug and when you first notice the bug. This will reduce the amount of code you will have to check before finding the code that\u2019s causing the bug. Disabling Assertions Assertions can be disabled by passing the -O option when running Python.","title":"Assertions"},{"location":"Python/#logging","text":"To enable the logging module to display log messages on your screen as your program runs, copy the following to the top of your program (but under the #! python shebang line): import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s - %(levelname)s - %(message)s ' ) Say you wrote a function to calculate the factorial of a number. In mathematics, factorial 4 is 1 \u00d7 2 \u00d7 3 \u00d7 4, or 24. Factorial 7 is 1 \u00d7 2 \u00d7 3 \u00d7 4 \u00d7 5 \u00d7 6 \u00d7 7, or 5,040. Open a new file editor window and enter the following code. It has a bug in it, but you will also enter several log messages to help yourself figure out what is going wrong. Save the program as factorialLog.py. >>> import logging >>> >>> logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s - %(levelname)s - %(message)s ' ) >>> >>> logging . debug ( 'Start of program' ) >>> >>> def factorial ( n ): >>> >>> logging . debug ( 'Start of factorial( %s )' % ( n )) >>> total = 1 >>> >>> for i in range ( 1 , n + 1 ): >>> total *= i >>> logging . debug ( 'i is ' + str ( i ) + ', total is ' + str ( total )) >>> >>> logging . debug ( 'End of factorial( %s )' % ( n )) >>> >>> return total >>> >>> print ( factorial ( 5 )) >>> logging . debug ( 'End of program' ) 2015 - 05 - 23 16 : 20 : 12 , 664 - DEBUG - Start of program 2015 - 05 - 23 16 : 20 : 12 , 664 - DEBUG - Start of factorial ( 5 ) 2015 - 05 - 23 16 : 20 : 12 , 665 - DEBUG - i is 0 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 668 - DEBUG - i is 1 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 670 - DEBUG - i is 2 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 673 - DEBUG - i is 3 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 675 - DEBUG - i is 4 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 678 - DEBUG - i is 5 , total is 0 2015 - 05 - 23 16 : 20 : 12 , 680 - DEBUG - End of factorial ( 5 ) 0 2015 - 05 - 23 16 : 20 : 12 , 684 - DEBUG - End of program","title":"Logging"},{"location":"Python/#logging-levels","text":"Logging levels provide a way to categorize your log messages by importance. There are five logging levels, described in Table 10-1 from least to most important. Messages can be logged at each level using a different logging function. Level Logging Function Description DEBUG logging.debug() The lowest level. Used for small details. Usually you care about these messages only when diagnosing problems. INFO logging.info() Used to record information on general events in your program or confirm that things are working at their point in the program. WARNING logging.warning() Used to indicate a potential problem that doesn't prevent the program from working but might do so in the future. ERROR logging.error() Used to record an error that caused the program to fail to do something. CRITICAL logging.critical() The highest level. Used to indicate a fatal error that has caused or is about to cause the program to stop running entirely.","title":"Logging Levels"},{"location":"Python/#disabling-logging","text":"After you\u2019ve debugged your program, you probably don\u2019t want all these log messages cluttering the screen. The logging.disable() function disables these so that you don\u2019t have to go into your program and remove all the logging calls by hand. >>> import logging >>> logging . basicConfig ( level = logging . INFO , format = ' %(asctime)s - %(levelname)s - %(message)s ' ) >>> logging . critical ( 'Critical error! Critical error!' ) 2015 - 05 - 22 11 : 10 : 48 , 054 - CRITICAL - Critical error ! Critical error ! >>> logging . disable ( logging . CRITICAL ) >>> logging . critical ( 'Critical error! Critical error!' ) >>> logging . error ( 'Error! Error!' )","title":"Disabling Logging"},{"location":"Python/#logging-to-a-file","text":"Instead of displaying the log messages to the screen, you can write them to a text file. The logging.basicConfig() function takes a filename keyword argument, like so: import logging logging . basicConfig ( filename = 'myProgramLog.txt' , level = logging . DEBUG , format = ' %(asctime)s - %(levelname)s - %(message)s ' )","title":"Logging to a File"},{"location":"Python/#lambda-functions","text":"This function: >>> def add ( x , y ): return x + y >>> add ( 5 , 3 ) 8 Is equivalent to the lambda function: >>> add = lambda x , y : x + y >>> add ( 5 , 3 ) 8 It's not even need to bind it to a name like add before: >>> ( lambda x , y : x + y )( 5 , 3 ) 8 Like regular nested functions, lambdas also work as lexical closures: >>> def make_adder ( n ): return lambda x : x + n >>> plus_3 = make_adder ( 3 ) >>> plus_5 = make_adder ( 5 ) >>> plus_3 ( 4 ) 7 >>> plus_5 ( 4 ) 9 Note : lambda can only evaluate an expression, like a single line of code.","title":"Lambda Functions"},{"location":"Python/#ternary-conditional-operator","text":"Many programming languages have a ternary operator, which define a conditional expression. The most common usage is to make a terse simple conditional assignment statement. In other words, it offers one-line code to evaluate the first expression if the condition is true, otherwise it evaluates the second expression. < expression1 > if < condition > else < expression2 > Example: >>> age = 15 >>> print ( 'kid' if age < 18 else 'adult' ) kid Ternary operators can be chained: >>> age = 15 >>> print ( 'kid' if age < 13 else 'teenager' if age < 18 else 'adult' ) teenager The code above is equivalent to: if age < 18 : if age < 13 : print ( 'kid' ) else : print ( 'teenager' ) else : print ( 'adult' )","title":"Ternary Conditional Operator"},{"location":"Python/#args-and-kwargs","text":"The names args and kwargs are arbitrary - the important thing are the * and ** operators. They can mean: In a function declaration, * means \u201cpack all remaining positional arguments into a tuple named <name> \u201d, while ** is the same for keyword arguments (except it uses a dictionary, not a tuple). In a function call, * means \u201cunpack tuple or list named <name> to positional arguments at this position\u201d, while ** is the same for keyword arguments. For example you can make a function that you can use to call any other function, no matter what parameters it has: def forward ( f , * args , ** kwargs ): return f ( * args , ** kwargs ) Inside forward, args is a tuple (of all positional arguments except the first one, because we specified it - the f), kwargs is a dict. Then we call f and unpack them so they become normal arguments to f. You use *args when you have an indefinite amount of positional arguments. >>> def fruits ( * args ): >>> for fruit in args : >>> print ( fruit ) >>> fruits ( \"apples\" , \"bananas\" , \"grapes\" ) \"apples\" \"bananas\" \"grapes\" Similarly, you use **kwargs when you have an indefinite number of keyword arguments. >>> def fruit ( ** kwargs ): >>> for key , value in kwargs . items (): >>> print ( \" {0} : {1} \" . format ( key , value )) >>> fruit ( name = \"apple\" , color = \"red\" ) name : apple color : red >>> def show ( arg1 , arg2 , * args , kwarg1 = None , kwarg2 = None , ** kwargs ): >>> print ( arg1 ) >>> print ( arg2 ) >>> print ( args ) >>> print ( kwarg1 ) >>> print ( kwarg2 ) >>> print ( kwargs ) >>> data1 = [ 1 , 2 , 3 ] >>> data2 = [ 4 , 5 , 6 ] >>> data3 = { 'a' : 7 , 'b' : 8 , 'c' : 9 } >>> show ( * data1 , * data2 , kwarg1 = \"python\" , kwarg2 = \"cheatsheet\" , ** data3 ) 1 2 ( 3 , 4 , 5 , 6 ) python cheatsheet { 'a' : 7 , 'b' : 8 , 'c' : 9 } >>> show ( * data1 , * data2 , ** data3 ) 1 2 ( 3 , 4 , 5 , 6 ) None None { 'a' : 7 , 'b' : 8 , 'c' : 9 } # If you do not specify ** for kwargs >>> show ( * data1 , * data2 , * data3 ) 1 2 ( 3 , 4 , 5 , 6 , \"a\" , \"b\" , \"c\" ) None None {}","title":"args and kwargs"},{"location":"Python/#things-to-rememberargs","text":"Functions can accept a variable number of positional arguments by using *args in the def statement. You can use the items from a sequence as the positional arguments for a function with the * operator. Using the * operator with a generator may cause your program to run out of memory and crash. Adding new positional parameters to functions that accept *args can introduce hard-to-find bugs.","title":"Things to Remember(args)"},{"location":"Python/#things-to-rememberkwargs","text":"Function arguments can be specified by position or by keyword. Keywords make it clear what the purpose of each argument is when it would be confusing with only positional arguments. Keyword arguments with default values make it easy to add new behaviors to a function, especially when the function has existing callers. Optional keyword arguments should always be passed by keyword instead of by position.","title":"Things to Remember(kwargs)"},{"location":"Python/#context-manager","text":"While Python's context managers are widely used, few understand the purpose behind their use. These statements, commonly used with reading and writing files, assist the application in conserving system memory and improve resource management by ensuring specific resources are only in use for certain processes.","title":"Context Manager"},{"location":"Python/#with-statement","text":"A context manager is an object that is notified when a context (a block of code) starts and ends. You commonly use one with the with statement. It takes care of the notifying. For example, file objects are context managers. When a context ends, the file object is closed automatically: >>> with open ( filename ) as f : >>> file_contents = f . read () # the open_file object has automatically been closed. Anything that ends execution of the block causes the context manager's exit method to be called. This includes exceptions, and can be useful when an error causes you to prematurely exit from an open file or connection. Exiting a script without properly closing files/connections is a bad idea, that may cause data loss or other problems. By using a context manager you can ensure that precautions are always taken to prevent damage or loss in this way.","title":"with statement"},{"location":"Python/#writing-your-own-contextmanager-using-generator-syntax","text":"It is also possible to write a context manager using generator syntax thanks to the contextlib.contextmanager decorator: >>> import contextlib >>> @contextlib . contextmanager ... def context_manager ( num ): ... print ( 'Enter' ) ... yield num + 1 ... print ( 'Exit' ) >>> with context_manager ( 2 ) as cm : ... # the following instructions are run when the 'yield' point of the context ... # manager is reached. ... # 'cm' will have the value that was yielded ... print ( 'Right in the middle with cm = {} ' . format ( cm )) Enter Right in the middle with cm = 3 Exit >>>","title":"Writing your own contextmanager using generator syntax"},{"location":"Python/#__main__-top-level-script-environment","text":"__main__ is the name of the scope in which top-level code executes. A module\u2019s name is set equal to __main__ when read from standard input, a script, or from an interactive prompt. A module can discover whether or not it is running in the main scope by checking its own __name__ , which allows a common idiom for conditionally executing code in a module when it is run as a script or with python -m but not when it is imported: >>> if __name__ == \"__main__\" : ... # execute only if run as a script ... main () For a package, the same effect can be achieved by including a main .py module, the contents of which will be executed when the module is run with -m For example we are developing script which is designed to be used as module, we should do: >>> # Python program to execute function directly >>> def add ( a , b ): ... return a + b ... >>> add ( 10 , 20 ) # we can test it by calling the function save it as calculate.py 30 >>> # Now if we want to use that module by importing we have to comment out our call, >>> # Instead we can write like this in calculate.py >>> if __name__ == \"__main__\" : ... add ( 3 , 5 ) ... >>> import calculate >> 8","title":"__main__ Top-level script environment"},{"location":"Python/#advantages","text":"Every Python module has it\u2019s __name__ defined and if this is __main__ , it implies that the module is being run standalone by the user and we can do corresponding appropriate actions. If you import this script as a module in another script, the name is set to the name of the script/module. Python files can act as either reusable modules, or as standalone programs. if __name__ == \u201cmain\u201d: is used to execute some code only if the file was run directly, and not imported.","title":"Advantages"},{"location":"Python/#setuppy","text":"The setup script is the centre of all activity in building, distributing, and installing modules using the Distutils. The main purpose of the setup script is to describe your module distribution to the Distutils, so that the various commands that operate on your modules do the right thing. The setup.py file is at the heart of a Python project. It describes all of the metadata about your project. There a quite a few fields you can add to a project to give it a rich set of metadata describing the project. However, there are only three required fields: name, version, and packages. The name field must be unique if you wish to publish your package on the Python Package Index (PyPI). The version field keeps track of different releases of the project. The packages field describes where you\u2019ve put the Python source code within your project. This allows you to easily install Python packages. Often it's enough to write: python setup . py install and module will install itself. Our initial setup.py will also include information about the license and will re-use the README.txt file for the long_description field. This will look like: >>> from distutils.core import setup >>> setup ( ... name = 'pythonCheatsheet' , ... version = '0.1' , ... packages = [ 'pipenv' ,], ... license = 'MIT' , ... long_description = open ( 'README.txt' ) . read (), ... ) Find more information visit http://docs.python.org/install/index.html .","title":"setup.py"},{"location":"Python/#dataclasses","text":"Dataclasses are python classes but are suited for storing data objects. This module provides a decorator and functions for automatically adding generated special methods such as __init__() and __repr__() to user-defined classes.","title":"Dataclasses"},{"location":"Python/#features","text":"They store data and represent a certain data type. Ex: A number. For people familiar with ORMs, a model instance is a data object. It represents a specific kind of entity. It holds attributes that define or represent the entity. They can be compared to other objects of the same type. Ex: A number can be greater than, less than, or equal to another number. Python 3.7 provides a decorator dataclass that is used to convert a class into a dataclass. python 2.7 >>> class Number : ... def __init__ ( self , val ): ... self . val = val ... >>> obj = Number ( 2 ) >>> obj . val 2 with dataclass >>> @dataclass ... class Number : ... val : int ... >>> obj = Number ( 2 ) >>> obj . val 2","title":"Features"},{"location":"Python/#default-values","text":"It is easy to add default values to the fields of your data class. >>> @dataclass ... class Product : ... name : str ... count : int = 0 ... price : float = 0.0 ... >>> obj = Product ( \"Python\" ) >>> obj . name Python >>> obj . count 0 >>> obj . price 0.0","title":"Default values"},{"location":"Python/#type-hints","text":"It is mandatory to define the data type in dataclass. However, If you don't want specify the datatype then, use typing.Any . >>> from dataclasses import dataclass >>> from typing import Any >>> @dataclass ... class WithoutExplicitTypes : ... name : Any ... value : Any = 42 ...","title":"Type hints"},{"location":"Python/#virtual-environment","text":"The use of a Virtual Environment is to test python code in encapsulated environments and to also avoid filling the base Python installation with libraries we might use for only one project.","title":"Virtual Environment"},{"location":"Python/#virtualenv","text":"Install virtualenv pip install virtualenv Install virtualenvwrapper-win (Windows) pip install virtualenvwrapper-win Usage : Make a Virtual Environment mkvirtualenv HelloWold Anything we install now will be specific to this project. And available to the projects we connect to this environment. Set Project Directory To bind our virtualenv with our current working directory we simply enter: setprojectdir . Deactivate To move onto something else in the command line type \u2018deactivate\u2019 to deactivate your environment. deactivate Notice how the parenthesis disappear. Workon Open up the command prompt and type \u2018workon HelloWold\u2019 to activate the environment and move into your root project folder workon HelloWold","title":"virtualenv"},{"location":"Python/#poetry","text":"[Poetry](https://poetry.eustace.io/) is a tool for dependency management and packaging in Python. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you. Install Poetry pip install --user poetry Create a new project poetry new my-project This will create a my-project directory: my-project \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.rst \u251c\u2500\u2500 poetry_demo \u2502 \u2514\u2500\u2500 __init__.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_demo.py The pyproject.toml file will orchestrate your project and its dependencies: [tool.poetry] name = \"my-project\" version = \"0.1.0\" description = \"\" authors = [ \"your name <your@mail.com>\" ] [tool.poetry.dependencies] python = \"*\" [tool.poetry.dev-dependencies] pytest = \"^3.4\" Packages To add dependencies to your project, you can specify them in the tool.poetry.dependencies section: [tool.poetry.dependencies] pendulum = \"^1.4\" Also, instead of modifying the pyproject.toml file by hand, you can use the add command and it will automatically find a suitable version constraint. $ poetry add pendulum To install the dependencies listed in the pyproject.toml: poetry install To remove dependencies: poetry remove pendulum For more information, check the documentation .","title":"poetry"},{"location":"Python/#pipenv","text":"[Pipenv](https://pipenv.readthedocs.io/en/latest/) is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. Windows is a first-class citizen, in our world. Install pipenv pip install pipenv Enter your Project directory and install the Packages for your project cd my_project pipenv install <package> Pipenv will install your package and create a Pipfile for you in your project\u2019s directory. The Pipfile is used to track which dependencies your project needs in case you need to re-install them. Uninstall Packages pipenv uninstall <package> Activate the Virtual Environment associated with your Python project pipenv shell Exit the Virtual Environment exit Find more information and a video in docs.pipenv.org .","title":"pipenv"},{"location":"Python/#anaconda","text":"Anaconda is another popular tool to manage python packages. Where packages, notebooks, projects and environments are shared. Your place for free public conda package hosting. Usage: Make a Virtual Environment conda create -n HelloWorld To use the Virtual Environment, activate it by: conda activate HelloWorld Anything installed now will be specific to the project HelloWorld Exit the Virtual Environment conda deactivate","title":"anaconda"}]}